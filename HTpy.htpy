


indent_nested_curly_braces(input_string)
{
indent_size := 4
current_indent := 0
result := ""
;MsgBox, % input_string
input_string := input_string
Loop, Parse, input_string, `n, `r
{

trimmed_line := Trim(A_LoopField)

if (trimmed_line = Chr(123))
{

result .= ((Chr(32) . RepeatSpaces(current_indent)) . (trimmed_line . "`n"))
current_indent := current_indent + indent_size
}
else if (trimmed_line = Chr(125))
{

current_indent := current_indent - indent_size
result .= ((Chr(32) . RepeatSpaces(current_indent)) . (trimmed_line . "`n"))
}
else
{

result .= ((Chr(32) . RepeatSpaces(current_indent)) . (trimmed_line . "`n"))
}

}

; Return the result
return result
}

RepeatSpaces(count)
{
spaces := ""
Loop, % count
{
spaces .= Chr(32)
}
return spaces
}



ifTheLineIsAFuncDec(strgjvkh, theFuncWeFound)
{
Loop, Parse, theFuncWeFound, `n, `r
{

numOfChars := 0
Loop, Parse, A_LoopField
{
numOfChars++
}

ALoopFieldd := StrSplit(A_LoopField, Chr(40), 1)
ALoopFieldd2 := StrSplit(strgjvkh, Chr(40), 1)

if (SubStr(ALoopFieldd, 1, numOfChars) = ALoopFieldd2) && (InStr(strgjvkh, Chr(40)))
{
return true
}


}

return false
}






isVarAnumKindaVar(strrrrr)
{

strLettersStart := 48
Loop, 10
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}

if (InStr(strrrrr, Chr(95)))
{
return true
}


return false
}

varDetect(strrrrr)
{

strLettersStart := 97
Loop, 26
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}


strLettersStart := 65
Loop, 26
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}


strLettersStart := 48
Loop, 10
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}

if (InStr(strrrrr, Chr(95)))
{
return true
}

if (InStr(strrrrr, Chr(37)))
{
return true
}

return false
}


funcToChecIfVaidNameForFunc(strrrrr)
{
    ; Check if the string is empty
    if (!(strrrrr))
    {
        ;MsgBox, Invalid function name: %strrrrr% (empty string)
        return false
    }

    ; Check if the first character is a digit (invalid for function name)
    firstChar := SubStr(strrrrr, 1, 1)
    if (firstChar >= "0" && firstChar <= "9")
    {
     ;   MsgBox, Invalid function name: %strrrrr% (starts with a digit)
        return false
    }

    ; Initialize a flag for validation
    isValid := true

    ; Loop through each character in the string using Loop, Parse
    Loop, Parse, strrrrr
    {
        ; Check the current parsed item (character)
        char := A_LoopField

        ; Check if the character is a valid letter, digit, or underscore
        if (!(char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char = "_"))
        {
           ; MsgBox, Invalid character %char% in function name: %strrrrr%
            isValid := false
            break
        }
    }

    ; If passed all checks, return true (valid function name)
    return isValid
}

transpileVariables(str123455, functionNames)
{
str123455 := Trim(str123455)
numOfStrings := 0

outOftranspileVariables := ""
outOftranspileVariablesOut := str123455


outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(40), " ( ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(41), " ) ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(44), " , ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(60), " < ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(62), " > ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(91), " [ ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(93), " ] ")

wasHereVarTryUhBug := 1

Loop, Parse, outOftranspileVariablesOut, " "
{
howManyCharIfVar := 0
Loop, Parse, A_LoopField
{
if (varDetect(A_LoopField))
{
howManyCharIfVar++
}
}
howManyCharIfVar2 := 0
Loop, Parse, A_LoopField
{
howManyCharIfVar2++
}
istAvar := 0
if (howManyCharIfVar = howManyCharIfVar2)
{
istAvar := 1
}

if (istAvar = 1)
{

howManyCharIfVar := 0
Loop, Parse, A_LoopField
{
if (isVarAnumKindaVar(A_LoopField))
{
howManyCharIfVar++
}
}

howManyCharIfVar2 := 0
Loop, Parse, A_LoopField
{
howManyCharIfVar2++
}
isNumKindaVar := 0
if (howManyCharIfVar2 = howManyCharIfVar)
{
isNumKindaVar := 1
}

if (isNumKindaVar = 1)
{
outOftranspileVariables .= A_LoopField . Chr(32)
}
else
{

if (InStr(A_LoopField, "%"))
{
if ((SubStr(Trim(A_LoopField), 1, 1) = "%") && (SubStr(Trim(A_LoopField), 0) = "%"))
{
StringTrimRight, var1, A_LoopField, 1
StringTrimLeft, var1, var1, 1

out1 := "variables['" . var1 . "']"
outOftranspileVariables .= out1 . Chr(32)
}
else
{
var1 := StrSplit(A_LoopField, "%", 1)
var2 := StrSplit(A_LoopField, "%", 2)
out1 := "variables[f" . Chr(39) . var1 . "{variables[" . Chr(34) . var2 . Chr(34) . "]}" . Chr(39) . "]"
outOftranspileVariables .= out1 . Chr(32)
}
}
else
{
out1 := "variables[" . Chr(39) . A_LoopField . Chr(39) . "]"
outOftranspileVariables .= out1 . Chr(32)
}
}


}
else
{
outOftranspileVariables .= A_LoopField . Chr(32)
}
wasHereVarTryUhBug := 0
}

if (wasHereVarTryUhBug = 1)
{
outOftranspileVariables := outOftranspileVariablesOut
}

;OutputDebug, |%outOftranspileVariables%|


Loop, Parse, functionNames, "|"
{
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['" . A_LoopField . "']", A_LoopField)
}


Loop, % numOfStrings
{
outOftranspileVariables := StrReplace(outOftranspileVariables, "freeeeepaestine-sav-etehmtyeah-freee-n" . A_Index, Chr(34) . theString%A_Index% . Chr(34))
}

weEverUseVars := "# Define a dictionary to store dynamic variables`nvariables = {}`n`n"
;OutputDebug, |%outOftranspileVariables%|
outOftranspileVariables := Trim(outOftranspileVariables)

outOftranspileVariables := StrReplace(outOftranspileVariables, Chr(96), Chr(92))
outOftranspileVariables := StrReplace(outOftranspileVariables, Chr(92) . Chr(92), Chr(96))
outOftranspileVariables := StrReplace(outOftranspileVariables, "cyiasasasasstAYtheummonlyemlpystringya-a-" . Chr(100), Chr(34) . Chr(34))


;OutputDebug, %outOftranspileVariables%

outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['True']", "True")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['False']", "False")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['true']", "True")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['false']", "False")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['if']", "if")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['else']", "else")

outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['and']", "and")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['or']", "or")

outOftranspileVariables := StrReplace(outOftranspileVariables, "!", " not ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " && ", " and ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " || ", " or ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " < = ", " <= ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " > = ", " >= ")
outOftranspileVariables := StrReplace(outOftranspileVariables, "not ==", " != ")
outOftranspileVariables := StrReplace(outOftranspileVariables, "  not == ", " != ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " not == ", " != ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " not ==", " != ")
outOftranspileVariables := StrReplace(outOftranspileVariables, "not ==", " != ")
outOftranspileVariables := StrReplace(outOftranspileVariables, "  not = ", " != ")
outOftranspileVariables := StrReplace(outOftranspileVariables, "not =", " != ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " = ", " == ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " = ", " == ")


outOftranspileVariables := StrReplace(outOftranspileVariables, " (", "(")
outOftranspileVariables := StrReplace(outOftranspileVariables, ") ", ")")

outOftranspileVariables := StrReplace(outOftranspileVariables, ").", ") .")
outOftranspileVariables := StrReplace(outOftranspileVariables, ".(", ". (")


outOftranspileVariables := StrReplace(outOftranspileVariables, "  >= ", " >= ")
outOftranspileVariables := StrReplace(outOftranspileVariables, "  <= ", " <= ")

outOftranspileVariables := StrReplace(outOftranspileVariables, " . ", " + ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " ,  ", ", ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " [ ", "[")
outOftranspileVariables := StrReplace(outOftranspileVariables, " ] ", "]")

outOftranspileVariables := StrReplace(outOftranspileVariables, "!=", " !=")

;OutputDebug, %outOftranspileVariables%

return outOftranspileVariables
}







transpileLowVariables(sstr)
{
sstr := Trim(sstr)

outOftranspileVariablesOut := Chr(34)
if (InStr(sstr, Chr(37)))
{
Loop, Parse, sstr, "%"
{

if (Mod(A_Index, 2))
{
outOftranspileVariablesOut .= A_LoopField
}
else
{
outOftranspileVariablesOut .= Chr(34) . " + variables['" . A_LoopField . Chr(39) . Chr(93) . " + " . Chr(34)
}

}
}
else
{
sstr := Chr(34) . sstr . Chr(34)
return sstr
}

outOftranspileVariablesOut := outOftranspileVariablesOut . Chr(34)
return outOftranspileVariablesOut
}


; the compiler
compiler(HTpyCode)
{
nothing := ""
HTpyCode := StrReplace(HTpyCode, Chr(13), nothing)
pyCode := ""
out := ""
HTpyCodeD1 := ""
skipLeftCuleyForFuncPLS := 0
eavbnsalvbaslv := 0
port := "8000"
Loop, Parse, HTpyCode, `n, `r
{
if (A_Index = 1)
{
HTpyCodeD1 .= Trim(A_LoopField) . "`n"
}
else
{

if (Trim(A_LoopField) = Chr(123)) && (eavbnsalvbaslv = 1)
{
; nothing
nothing := ""
}
else
{
HTpyCodeD1 .= Trim(A_LoopField) . "`n"
}

eavbnsalvbaslv := 0
if (Trim(A_LoopField) = "")
{
eavbnsalvbaslv := 1
}


}



}
StringTrimRight, HTpyCode, HTpyCodeD1, 1



HTpyCodeOUT754754 := ""
areWEinSome34sNum := 0
theIdNumOfThe34 := 0

Loop, Parse, HTpyCode
{
theIdNumOfThe34theVar%A_Index% := Chr(34)
}

Loop, Parse, HTpyCode
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = Chr(96))
{
theIdNumOfThe34theVar%theIdNumOfThe34% .= Chr(92)
}
else
{
theIdNumOfThe34theVar%theIdNumOfThe34% .= A_LoopField
}
}
else
{
theIdNumOfThe34++
HTpyCodeOUT754754 .= "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . str(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
HTpyCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
HTpyCode := HTpyCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar%A_Index% .= Chr(34)
}


str23IfFuncInNAMEnum := 0

CheckIFandElsesss1 := "if ("
CheckIFandElsesss2 := "if("
CheckIFandElsesss3 := "if !("
CheckIFandElsesss4 := "if!("
CheckIFandElsesss5 := "else if ("
CheckIFandElsesss6 := "else if("
CheckIFandElsesss7 := "else if !("
CheckIFandElsesss8 := "else if!("
CheckIFandElsesssNum := 0



func_LoopParseFunc_func := "`ndef LoopParseFunc(var, delimiter1=" . Chr(34) . "" . Chr(34) . ", delimiter2=" . Chr(34) . "" . Chr(34) . "):`n    import re`n    if not delimiter1 and not delimiter2:`n        # If no delimiters are provided, return a list of characters`n        items = list(var)`n    else:`n        # Construct the regular expression pattern for splitting the string`n        pattern = r'[' + re.escape(delimiter1) + re.escape(delimiter2) + r']+'`n`n        # Split the string using the constructed pattern`n        items = re.split(pattern, var)`n`n    return items`n`n"


func_InStr_func := "`ndef InStr(Haystack, Needle, CaseSensitive=True, StartingPos=1, Occurrence=1):`n    if Haystack is None or Needle is None:`n        return False`n    StartingPos = max(StartingPos, 1)`n    if not CaseSensitive:`n        Haystack = Haystack.lower()`n        Needle = Needle.lower()`n    count = 0`n    for i in range(StartingPos - 1, len(Haystack)):`n        if Haystack[i:i + len(Needle)] == Needle:`n            count += 1`n            if count == Occurrence:`n                return True`n    return False  `n"

func_SubStr_func := "`ndef SubStr(str, startPos, length=None):`n    if str is None or str == " . Chr(34) . "" . Chr(34) . ":`n        return " . Chr(34) . "" . Chr(34) . "`n`n    if length is None or length == " . Chr(34) . "" . Chr(34) . ":`n        length = len(str) - startPos + 1`n`n    if startPos < 1:`n        startPos = len(str) + startPos`n`n    return str[startPos - 1:startPos - 1 + length]`n"


func_Trim_func := "`ndef Trim(inputString):`n    if inputString is None:`n        return " . Chr(34) . "" . Chr(34) . "`n`n    return inputString.strip()`n"


func_StrReplace_func := "  `ndef StrReplace(originalString, find, replaceWith):`n    # Use the replace method to replace occurrences of 'find' with 'replaceWith'`n    return originalString.replace(find, replaceWith)`n"


func_StringTrimLeft_func := "`ndef StringTrimLeft(input, numChars):`n    # Convert input to a string if it's not already a string`n    if not isinstance(input, str):`n        input = str(input)  # Convert input to string`n`n    # Check if the input is long enough to perform trimming`n    if len(input) >= numChars:`n        return input[numChars:]  # Trim the string from the left`n    else:`n        return input  # Return input unchanged if numChars is larger than string length`n"


func_StringTrimRight_func := "`ndef StringTrimRight(input, numChars):`n    # Convert input to a string if it's not already a string`n    if not isinstance(input, str):`n        input = str(input)  # Convert input to string`n`n    # Check if the input is long enough to perform trimming`n    if len(input) >= numChars:`n        return input[:-numChars]  # Trim the string from the right`n    else:`n        return input  # Return input unchanged if numChars is larger than string length`n"


func_StrLower_func := "`ndef StrLower(string):`n    return string.lower()`n"


func_RegExReplace_func := "`ndef RegExReplace(inputStr, regexPattern, replacement):`n    # Create a regular expression object using the provided pattern`n    import re`n    regex = re.compile(regexPattern, re.MULTILINE)  # re.MULTILINE for multi-line matching`n`n    # Use the sub() method to perform the regex replacement`n    resultStr = regex.sub(replacement, inputStr)`n`n    # Return the modified string`n    return resultStr`n"


func_StrSplit_func := "`ndef StrSplit(inputStr, delimiter, num):`n    # Check if the delimiter is empty`n    if delimiter == '':`n        # Return an empty string since splitting with an empty delimiter is not possible`n        return ''`n`n    # Split the input string based on the delimiter`n    parts = inputStr.split(delimiter)`n`n    # Return the part specified by the num parameter (1-based index)`n    if 0 < num <= len(parts):`n        return parts[num - 1]  # Return the specified part (0-based index)`n    else:`n        return ''  # Return an empty string if num is out of range`n"

func_Chr_func := "`ndef Chr(number):`n    # Check if the number is None`n    if number is None:`n        # Return an empty string`n        return " . Chr(34) . "" . Chr(34) . "`n`n    # Check if the number is within the valid Unicode range`n    if 0 <= number <= 0x10FFFF:`n        # Convert the number to a character using chr()`n        return chr(number)`n    else:`n        # Return an empty string for invalid numbers`n        return " . Chr(34) . "" . Chr(34) . "`n`n"

func_Mod_func := "`n# Custom Mod function in Python`ndef Mod(dividend, divisor):`n    return dividend % divisor`n"



func_HTpy_func := "`ndef HTpy():`n    import sys`n    import os`n    if len(sys.argv) < 2 or len(sys.argv) > 3:`n        print(" . Chr(34) . "Usage: python app.py <input_file.htpy> [run]" . Chr(34) . ")`n        sys.exit(1)`n`n    input_file = sys.argv[1]`n`n    # Ensure the input_file ends with '.htpy'`n    if not input_file.endswith('.htpy'):`n        print(" . Chr(34) . "Error: Input file must have a .htpy extension." . Chr(34) . ")`n        sys.exit(1)`n`n    # Check if the input_file exists`n    if not os.path.isfile(input_file):`n        print(f" . Chr(34) . "Error: '{input_file}' is not a valid file path." . Chr(34) . ")`n        sys.exit(1)`n`n    # Determine the output .py file name based on input file name`n    output_file = os.path.splitext(input_file)[0] + '.py'`n`n    # Compile the .htpy content using the compiler function`n    with open(input_file, 'r') as file:`n        htpy_content = file.read()`n`n    compiled_result = compiler(htpy_content)`n`n    # Save the compiled result to the determined .py output file`n    with open(output_file, 'w') as file:`n        file.write(compiled_result)`n`n    print(f" . Chr(34) . "Compiled result saved to '{output_file}'." . Chr(34) . ")`n`n    # Check if 'run' parameter is provided and execute the compiled Python script`n    if len(sys.argv) == 3 and sys.argv[2] == 'run':`n        print(f" . Chr(34) . "Running '{output_file}'..." . Chr(34) . ")`n        try:`n            exec(compile(open(output_file).read(), output_file, 'exec'), globals())`n        except Exception as e:`n            print(f" . Chr(34) . "Error occurred while running the compiled file: {e}" . Chr(34) . ")`n`n"




func_FileRead_func := Chr(10) . Chr(105) . Chr(109) . Chr(112) . Chr(111) . Chr(114) . Chr(116) . Chr(32) . Chr(111) . Chr(115) . Chr(10) . Chr(100) . Chr(101) . Chr(102) . Chr(32) . Chr(70) . Chr(105) . Chr(108) . Chr(101) . Chr(82) . Chr(101) . Chr(97) . Chr(100) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(35) . Chr(32) . Chr(82) . Chr(101) . Chr(109) . Chr(111) . Chr(118) . Chr(101) . Chr(32) . Chr(97) . Chr(110) . Chr(121) . Chr(32) . Chr(101) . Chr(120) . Chr(116) . Chr(114) . Chr(97) . Chr(32) . Chr(100) . Chr(111) . Chr(117) . Chr(98) . Chr(108) . Chr(101) . Chr(32) . Chr(113) . Chr(117) . Chr(111) . Chr(116) . Chr(101) . Chr(115) . Chr(32) . Chr(97) . Chr(114) . Chr(111) . Chr(117) . Chr(110) . Chr(100) . Chr(32) . Chr(116) . Chr(104) . Chr(101) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(32) . Chr(61) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(115) . Chr(116) . Chr(114) . Chr(105) . Chr(112) . Chr(40) . Chr(39) . Chr(34) . Chr(39) . Chr(41) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(35) . Chr(32) . Chr(69) . Chr(110) . Chr(115) . Chr(117) . Chr(114) . Chr(101) . Chr(32) . Chr(116) . Chr(104) . Chr(101) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(32) . Chr(105) . Chr(115) . Chr(32) . Chr(97) . Chr(98) . Chr(115) . Chr(111) . Chr(108) . Chr(117) . Chr(116) . Chr(101) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(105) . Chr(102) . Chr(32) . Chr(110) . Chr(111) . Chr(116) . Chr(32) . Chr(111) . Chr(115) . Chr(46) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(105) . Chr(115) . Chr(97) . Chr(98) . Chr(115) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(32) . Chr(61) . Chr(32) . Chr(111) . Chr(115) . Chr(46) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(106) . Chr(111) . Chr(105) . Chr(110) . Chr(40) . Chr(111) . Chr(115) . Chr(46) . Chr(103) . Chr(101) . Chr(116) . Chr(99) . Chr(119) . Chr(100) . Chr(40) . Chr(41) . Chr(44) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(116) . Chr(114) . Chr(121) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(119) . Chr(105) . Chr(116) . Chr(104) . Chr(32) . Chr(111) . Chr(112) . Chr(101) . Chr(110) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(44) . Chr(32) . Chr(39) . Chr(114) . Chr(39) . Chr(44) . Chr(32) . Chr(101) . Chr(110) . Chr(99) . Chr(111) . Chr(100) . Chr(105) . Chr(110) . Chr(103) . Chr(61) . Chr(39) . Chr(117) . Chr(116) . Chr(102) . Chr(45) . Chr(56) . Chr(39) . Chr(44) . Chr(32) . Chr(101) . Chr(114) . Chr(114) . Chr(111) . Chr(114) . Chr(115) . Chr(61) . Chr(39) . Chr(105) . Chr(103) . Chr(110) . Chr(111) . Chr(114) . Chr(101) . Chr(39) . Chr(41) . Chr(32) . Chr(97) . Chr(115) . Chr(32) . Chr(102) . Chr(105) . Chr(108) . Chr(101) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(99) . Chr(111) . Chr(110) . Chr(116) . Chr(101) . Chr(110) . Chr(116) . Chr(32) . Chr(61) . Chr(32) . Chr(102) . Chr(105) . Chr(108) . Chr(101) . Chr(46) . Chr(114) . Chr(101) . Chr(97) . Chr(100) . Chr(40) . Chr(41) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(114) . Chr(101) . Chr(116) . Chr(117) . Chr(114) . Chr(110) . Chr(32) . Chr(99) . Chr(111) . Chr(110) . Chr(116) . Chr(101) . Chr(110) . Chr(116) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(101) . Chr(120) . Chr(99) . Chr(101) . Chr(112) . Chr(116) . Chr(32) . Chr(70) . Chr(105) . Chr(108) . Chr(101) . Chr(78) . Chr(111) . Chr(116) . Chr(70) . Chr(111) . Chr(117) . Chr(110) . Chr(100) . Chr(69) . Chr(114) . Chr(114) . Chr(111) . Chr(114) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(114) . Chr(101) . Chr(116) . Chr(117) . Chr(114) . Chr(110) . Chr(32) . Chr(39) . Chr(39) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(101) . Chr(120) . Chr(99) . Chr(101) . Chr(112) . Chr(116) . Chr(32) . Chr(69) . Chr(120) . Chr(99) . Chr(101) . Chr(112) . Chr(116) . Chr(105) . Chr(111) . Chr(110) . Chr(32) . Chr(97) . Chr(115) . Chr(32) . Chr(101) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(114) . Chr(101) . Chr(116) . Chr(117) . Chr(114) . Chr(110) . Chr(32) . Chr(78) . Chr(111) . Chr(110) . Chr(101) . Chr(10)

func_FileAppend_func := Chr(10) . Chr(105) . Chr(109) . Chr(112) . Chr(111) . Chr(114) . Chr(116) . Chr(32) . Chr(111) . Chr(115) . Chr(10) . Chr(100) . Chr(101) . Chr(102) . Chr(32) . Chr(70) . Chr(105) . Chr(108) . Chr(101) . Chr(65) . Chr(112) . Chr(112) . Chr(101) . Chr(110) . Chr(100) . Chr(40) . Chr(99) . Chr(111) . Chr(110) . Chr(116) . Chr(101) . Chr(110) . Chr(116) . Chr(44) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(35) . Chr(32) . Chr(82) . Chr(101) . Chr(109) . Chr(111) . Chr(118) . Chr(101) . Chr(32) . Chr(97) . Chr(110) . Chr(121) . Chr(32) . Chr(101) . Chr(120) . Chr(116) . Chr(114) . Chr(97) . Chr(32) . Chr(100) . Chr(111) . Chr(117) . Chr(98) . Chr(108) . Chr(101) . Chr(32) . Chr(113) . Chr(117) . Chr(111) . Chr(116) . Chr(101) . Chr(115) . Chr(32) . Chr(97) . Chr(114) . Chr(111) . Chr(117) . Chr(110) . Chr(100) . Chr(32) . Chr(116) . Chr(104) . Chr(101) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(32) . Chr(61) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(115) . Chr(116) . Chr(114) . Chr(105) . Chr(112) . Chr(40) . Chr(39) . Chr(34) . Chr(39) . Chr(41) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(35) . Chr(32) . Chr(69) . Chr(110) . Chr(115) . Chr(117) . Chr(114) . Chr(101) . Chr(32) . Chr(116) . Chr(104) . Chr(101) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(32) . Chr(105) . Chr(115) . Chr(32) . Chr(97) . Chr(98) . Chr(115) . Chr(111) . Chr(108) . Chr(117) . Chr(116) . Chr(101) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(105) . Chr(102) . Chr(32) . Chr(110) . Chr(111) . Chr(116) . Chr(32) . Chr(111) . Chr(115) . Chr(46) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(105) . Chr(115) . Chr(97) . Chr(98) . Chr(115) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(32) . Chr(61) . Chr(32) . Chr(111) . Chr(115) . Chr(46) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(106) . Chr(111) . Chr(105) . Chr(110) . Chr(40) . Chr(111) . Chr(115) . Chr(46) . Chr(103) . Chr(101) . Chr(116) . Chr(99) . Chr(119) . Chr(100) . Chr(40) . Chr(41) . Chr(44) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(116) . Chr(114) . Chr(121) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(119) . Chr(105) . Chr(116) . Chr(104) . Chr(32) . Chr(111) . Chr(112) . Chr(101) . Chr(110) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(44) . Chr(32) . Chr(39) . Chr(97) . Chr(39) . Chr(44) . Chr(32) . Chr(101) . Chr(110) . Chr(99) . Chr(111) . Chr(100) . Chr(105) . Chr(110) . Chr(103) . Chr(61) . Chr(39) . Chr(117) . Chr(116) . Chr(102) . Chr(45) . Chr(56) . Chr(39) . Chr(41) . Chr(32) . Chr(97) . Chr(115) . Chr(32) . Chr(102) . Chr(105) . Chr(108) . Chr(101) . Chr(58) . Chr(32) . Chr(32) . Chr(35) . Chr(32) . Chr(39) . Chr(97) . Chr(39) . Chr(32) . Chr(109) . Chr(111) . Chr(100) . Chr(101) . Chr(32) . Chr(102) . Chr(111) . Chr(114) . Chr(32) . Chr(97) . Chr(112) . Chr(112) . Chr(101) . Chr(110) . Chr(100) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(102) . Chr(105) . Chr(108) . Chr(101) . Chr(46) . Chr(119) . Chr(114) . Chr(105) . Chr(116) . Chr(101) . Chr(40) . Chr(99) . Chr(111) . Chr(110) . Chr(116) . Chr(101) . Chr(110) . Chr(116) . Chr(41) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(114) . Chr(101) . Chr(116) . Chr(117) . Chr(114) . Chr(110) . Chr(32) . Chr(84) . Chr(114) . Chr(117) . Chr(101) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(101) . Chr(120) . Chr(99) . Chr(101) . Chr(112) . Chr(116) . Chr(32) . Chr(69) . Chr(120) . Chr(99) . Chr(101) . Chr(112) . Chr(116) . Chr(105) . Chr(111) . Chr(110) . Chr(32) . Chr(97) . Chr(115) . Chr(32) . Chr(101) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(114) . Chr(101) . Chr(116) . Chr(117) . Chr(114) . Chr(110) . Chr(32) . Chr(70) . Chr(97) . Chr(108) . Chr(115) . Chr(101) . Chr(10)


func_FileDelete_func := Chr(10) . Chr(105) . Chr(109) . Chr(112) . Chr(111) . Chr(114) . Chr(116) . Chr(32) . Chr(111) . Chr(115) . Chr(10) . Chr(100) . Chr(101) . Chr(102) . Chr(32) . Chr(70) . Chr(105) . Chr(108) . Chr(101) . Chr(68) . Chr(101) . Chr(108) . Chr(101) . Chr(116) . Chr(101) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(35) . Chr(32) . Chr(69) . Chr(110) . Chr(115) . Chr(117) . Chr(114) . Chr(101) . Chr(32) . Chr(116) . Chr(104) . Chr(101) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(32) . Chr(105) . Chr(115) . Chr(32) . Chr(97) . Chr(98) . Chr(115) . Chr(111) . Chr(108) . Chr(117) . Chr(116) . Chr(101) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(105) . Chr(102) . Chr(32) . Chr(110) . Chr(111) . Chr(116) . Chr(32) . Chr(111) . Chr(115) . Chr(46) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(105) . Chr(115) . Chr(97) . Chr(98) . Chr(115) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(32) . Chr(61) . Chr(32) . Chr(111) . Chr(115) . Chr(46) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(106) . Chr(111) . Chr(105) . Chr(110) . Chr(40) . Chr(111) . Chr(115) . Chr(46) . Chr(103) . Chr(101) . Chr(116) . Chr(99) . Chr(119) . Chr(100) . Chr(40) . Chr(41) . Chr(44) . Chr(32) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(116) . Chr(114) . Chr(121) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(105) . Chr(102) . Chr(32) . Chr(111) . Chr(115) . Chr(46) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(46) . Chr(101) . Chr(120) . Chr(105) . Chr(115) . Chr(116) . Chr(115) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(111) . Chr(115) . Chr(46) . Chr(114) . Chr(101) . Chr(109) . Chr(111) . Chr(118) . Chr(101) . Chr(40) . Chr(112) . Chr(97) . Chr(116) . Chr(104) . Chr(41) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(101) . Chr(120) . Chr(99) . Chr(101) . Chr(112) . Chr(116) . Chr(32) . Chr(69) . Chr(120) . Chr(99) . Chr(101) . Chr(112) . Chr(116) . Chr(105) . Chr(111) . Chr(110) . Chr(58) . Chr(10) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(112) . Chr(97) . Chr(115) . Chr(115) . Chr(32) . Chr(32) . Chr(32) . Chr(32) . Chr(10) . Chr(10)



func_GetParams_func := "`nimport os`nimport sys`n`ndef GetParams():`n    # Check if any command line arguments are provided`n    if len(sys.argv) < 2:`n        return " . Chr(34) . "" . Chr(34) . "`n`n    # Store the provided command line arguments`n    params = []`n    for arg in sys.argv[1:]:`n        if os.path.exists(arg):`n            arg = os.path.abspath(arg)`n        params.append(arg)`n`n    return " . Chr(34) . "" . Chr(92) . "n" . Chr(34) . ".join(params)`n"


func_Floor_func := "`ndef Floor(num):`n    import math`n    if num is None or not isinstance(num, (int, float)):`n        return None`n    return math.floor(num)`n"

func_A_TickCount_func := "`nimport time`n`nstart_timestamp = int(time.time() * 1000)  # Initialize with current timestamp in milliseconds`n`n# Function to calculate tick count in milliseconds`ndef A_TickCount():`n    return int(time.time() * 1000) - start_timestamp`n"



func_RunCMD_func := "`nimport subprocess`ndef RunCMD(command):`n    try:`n        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)`n        return result.stdout`n    except subprocess.CalledProcessError as e:`n        print(f" . Chr(34) . "Error: {e}" . Chr(34) . ")`n        return e.stdout + " . Chr(34) . "" . Chr(92) . "n" . Chr(34) . " + e.stderr`n    except Exception as e:`n        print(f" . Chr(34) . "An unexpected error occurred: {e}" . Chr(34) . ")`n        return " . Chr(34) . "" . Chr(34) . "`n"


func_SortLikeAHK_func := "`nimport random`ndef SortLikeAHK(var_name, options):`n    # Determine delimiter based on options`n    delimiter = '" . Chr(92) . "n'`n    if 'D' in options:`n        delimiter = options[options.index('D') + 1]`n    `n    # Split the input variable by delimiter`n    items = var_name.split(delimiter)`n    `n    # Remove empty items and strip whitespace`n    items = [item.strip() for item in items if item.strip()]`n    `n    # Apply sorting based on options`n    if 'N' in options:`n        # Numeric sort`n        items.sort(key=lambda x: int(x))`n    elif 'Random' in options:`n        # Random sort`n        random.shuffle(items)`n    else:`n        # Default alphabetical sort`n        items.sort(key=lambda x: x.lower() if 'C' not in options else x)`n    `n    # Reverse if 'R' option is present`n    if 'R' in options:`n        items.reverse()`n    `n    # Remove duplicates if 'U' option is present`n    if 'U' in options:`n        seen = set()`n        unique_items = []`n        for item in items:`n            lower_item = item.lower() if 'C' not in options else item`n            if lower_item not in seen:`n                seen.add(lower_item)`n                unique_items.append(item)`n        items = unique_items`n    `n    # Join the sorted items back into a string`n    sorted_var = delimiter.join(items)`n    `n    return sorted_var`n"


func_BuildInVars_func := "`nimport time`nfrom datetime import datetime`n# Initialize with current timestamp`nlast_input_time = time.time() * 1000  # Convert to milliseconds`nstart_timestamp = time.time() * 1000  # Convert to milliseconds`n`n# Function to reset the idle timer`ndef reset_idle_timer():`n    global last_input_time`n    last_input_time = time.time() * 1000  # Update last input time in milliseconds`n`n# Function to calculate tick count in milliseconds`ndef A_TickCount():`n    return int(time.time() * 1000 - start_timestamp)`n`n# Function to build in variables`ndef BuildInVars(varName):`n    now = datetime.now()`n    if varName == " . Chr(34) . "A_TickCount" . Chr(34) . ":`n        # Return tick count in milliseconds`n        return A_TickCount()`n    elif varName == " . Chr(34) . "A_Now" . Chr(34) . ":`n        # Return current local timestamp`n        return now.strftime(" . Chr(34) . "%Y-%m-%d %H:%M:%S" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_YYYY" . Chr(34) . ":`n        # Return current year`n        return now.strftime(" . Chr(34) . "%Y" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_MM" . Chr(34) . ":`n        # Return current month`n        return now.strftime(" . Chr(34) . "%m" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_DD" . Chr(34) . ":`n        # Return current day`n        return now.strftime(" . Chr(34) . "%d" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_MMMM" . Chr(34) . ":`n        # Return full month name`n        return now.strftime(" . Chr(34) . "%B" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_MMM" . Chr(34) . ":`n        # Return short month name`n        return now.strftime(" . Chr(34) . "%b" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_DDDD" . Chr(34) . ":`n        # Return full day name`n        return now.strftime(" . Chr(34) . "%A" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_DDD" . Chr(34) . ":`n        # Return short day name`n        return now.strftime(" . Chr(34) . "%a" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_Hour" . Chr(34) . ":`n        # Return current hour`n        return now.strftime(" . Chr(34) . "%H" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_Min" . Chr(34) . ":`n        # Return current minute`n        return now.strftime(" . Chr(34) . "%M" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_Sec" . Chr(34) . ":`n        # Return current second`n        return now.strftime(" . Chr(34) . "%S" . Chr(34) . ")`n    elif varName == " . Chr(34) . "A_Space" . Chr(34) . ":`n        # Return space character`n        return " . Chr(34) . " " . Chr(34) . "`n    elif varName == " . Chr(34) . "A_Tab" . Chr(34) . ":`n        # Return tab character`n        return " . Chr(34) . Chr(92) . "t" . Chr(34) . "`n    else:`n        # Handle unknown variable names`n        return None`n"


func_Floor_func := "`ndef Floor(number):`n    if number > 0:`n        return int(number)`n    else:`n        return int(number) - (1 if number != int(number) else 0)`n`n"


func_ExitApp_func := "`nimport os`n# Function to handle application termination`ndef ExitApp():`n    os._exit(1)`n`n"


func_SetTimer_func := "`nimport time`nimport threading`n# Dictionary to store active timers`nactive_timers = {}`n`n# Function to start, stop, or adjust a timer`ndef SetTimer(func, timeOrOnOff):`n    def timer_wrapper(name, interval_ms):`n        def run_timer():`n            func()`n            if active_timers[name]['running']:`n                active_timers[name]['timer'] = threading.Timer(interval_ms / 1000.0, run_timer)`n                active_timers[name]['timer'].start()`n                `n        if timeOrOnOff == " . Chr(34) . "On" . Chr(34) . " and not active_timers[name]['running']:`n            active_timers[name]['timer'] = threading.Timer(active_timers[name]['interval_ms'] / 1000.0, run_timer)`n            active_timers[name]['timer'].start()`n            active_timers[name]['running'] = True`n            #print(f" . Chr(34) . "Timer '{name}' started with interval {active_timers[name]['interval_ms']} ms." . Chr(34) . ")`n        elif timeOrOnOff == " . Chr(34) . "Off" . Chr(34) . " and active_timers[name]['running']:`n            active_timers[name]['timer'].cancel()`n            active_timers[name]['running'] = False`n            #print(f" . Chr(34) . "Timer '{name}' stopped." . Chr(34) . ")`n        elif isinstance(timeOrOnOff, int):`n            active_timers[name]['interval_ms'] = timeOrOnOff  # Update the stored interval`n            if active_timers[name]['running']:`n                active_timers[name]['timer'].cancel()`n                active_timers[name]['timer'] = threading.Timer(timeOrOnOff / 1000.0, run_timer)`n                active_timers[name]['timer'].start()`n                #print(f" . Chr(34) . "Timer '{name}' adjusted to interval {timeOrOnOff} ms." . Chr(34) . ")`n            else:`n                active_timers[name]['timer'] = threading.Timer(timeOrOnOff / 1000.0, run_timer)`n                active_timers[name]['timer'].start()`n                active_timers[name]['running'] = True`n                #print(f" . Chr(34) . "Timer '{name}' started with adjusted interval {timeOrOnOff} ms." . Chr(34) . ")`n        else:`n            print(" . Chr(34) . "Invalid arguments. Please provide a valid function and time/On/Off state." . Chr(34) . ")`n`n    # Ensure func is callable`n    if not callable(func):`n        print(" . Chr(34) . "Invalid function provided." . Chr(34) . ")`n        return`n`n    name = func.__name__  # Use function name as timer identifier`n`n    # Initialize timer if not already active`n    if name not in active_timers:`n        active_timers[name] = {`n            'timer': None,`n            'running': False,`n            'interval_ms': 1000  # Default interval`n        }`n`n    # Determine the interval_ms value`n    if isinstance(timeOrOnOff, int):`n        interval_ms = timeOrOnOff`n    else:`n        interval_ms = active_timers[name]['interval_ms']  # Use stored interval`n`n    # Call timer_wrapper to manage timer based on timeOrOnOff`n    timer_wrapper(name, interval_ms)`n"

func_Abs_func := "`ndef Abs(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return abs(num)`n"
func_ACos_func := "`ndef ACos(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.acos(num)`n"
func_ASin_func := "`ndef ASin(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.asin(num)`n"
func_ATan_func := "`ndef ATan(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.atan(num)`n"
func_Ceil_func := "`ndef Ceil(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.ceil(num)`n"
func_Cos_func := "`ndef Cos(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.cos(num)`n"
func_Exp_func := "`ndef Exp(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.exp(num)`n"
func_Ln_func := "`ndef Ln(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.log(num)`n"
func_Log_func := "`ndef Log(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.log10(num)`n"
func_Round_func := "`ndef Round(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return round(num)`n"
func_Sin_func := "`ndef Sin(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.sin(num)`n"
func_Sqrt_func := "`ndef Sqrt(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.sqrt(num)`n"
func_Tan_func := "`ndef Tan(num):`n    import math`n    if num is None or math.isnan(num):`n        return None`n    return math.tan(num)`n"
func_RegExMatch_func := "`ndef RegExMatch(Haystack, NeedleRegEx, OutputVar=None, StartingPos=0):`n    import re`n    if Haystack is None or NeedleRegEx is None:`n        return None`n`n    regex = re.compile(NeedleRegEx)`n    match = regex.search(Haystack)`n`n    if match:`n        if OutputVar is not None:`n            OutputVar.append(match.group(0))`n        return match.start() + 1`n    else:`n        return 0`n"
func_StrLen_func := "`ndef StrLen(string):`n    if string is None:`n        return None`n    return len(string)`n"
func_Asc_func := "`ndef Asc(char):`n    if char is None or len(char) == 0:`n        return None`n    return ord(char[0])`n"
func_getDataFromAPI_func := "`nimport json`nimport urllib.request`nimport urllib.error`ndef getDataFromAPI(url):`n    try:`n        with urllib.request.urlopen(url) as response:`n            if response.getcode() == 200:`n                return response.read()`n            else:`n                return None`n    except urllib.error.URLError as e:`n        print(f" . Chr(34) . "Error accessing URL: {e.reason}" . Chr(34) . ")`n        return None`n"
func_getDataFromJSON_func := "`nimport json`nimport re`ndef getDataFromJSON(json_data, json_path):`n    try:`n        if json_data:`n            json_data = json.loads(json_data)  # Parse JSON data into Python object`n`n        # Check if the path starts with a dot and remove it if present`n        if json_path.startswith(" . Chr(34) . "." . Chr(34) . "):`n            json_path = json_path[1:]`n`n        path_segments = json_path.split(" . Chr(34) . "." . Chr(34) . ")  # Split the path into segments`n        current_data = json_data  # Use json_data directly (already an object)`n`n        for segment in path_segments:`n            if current_data is None:`n                return None`n`n            # Handle array indices e.g., " . Chr(34) . "Children[0]" . Chr(34) . "`n            if " . Chr(34) . "[" . Chr(34) . " in segment and " . Chr(34) . "]" . Chr(34) . " in segment:`n                array_index = re.search(r" . Chr(34) . "" . Chr(92) . "[(" . Chr(92) . "d+)" . Chr(92) . "]" . Chr(34) . ", segment)`n                if array_index:`n                    array_name = segment[:segment.index(" . Chr(34) . "[" . Chr(34) . ")]`n                    index = int(array_index.group(1))`n                    if array_name:`n                        current_data = current_data.get(array_name, [])[index]`n                    else:`n                        current_data = current_data[index]`n                    segment = segment[segment.index(" . Chr(34) . "]" . Chr(34) . ") + 1:]`n`n            # Handle regular dictionary keys`n            if segment:`n                current_data = current_data.get(segment, None)`n`n        return current_data`n`n    except (TypeError, IndexError, KeyError) as error:`n        print(f" . Chr(34) . "Error accessing data: {error}" . Chr(34) . ")`n        return None`n"

funcs_func := "LoopParseFunc|InStr|SubStr|Trim|StrReplace|StringTrimLeft|StringTrimRight|StrLower|RegExReplace|StrSplit|Chr|Mod|FileRead|FileAppend|FileDelete|GetParams|Floor|RunCMD|SortLikeAHK|BuildInVars|Floor|ExitApp|SetTimer|Abs|ACos|ASin|ATan|Ceil|Cos|Exp|Ln|Log|Round|Sin|Sqrt|Tan|RegExMatch|StrLen|Asc|getDataFromAPI|getDataFromJSON"



functionNames := "input|int|chr|str|InStr|SubStr|Trim|StrReplace|StringTrimLeft|StringTrimRight|StrLower|RegExReplace|StrSplit|Chr|Mod|FileRead|FileAppend|FileDelete|GetParams|RunCMD|SortLikeAHK|BuildInVars|Floor|ExitApp|SetTimer|Abs|ACos|ASin|ATan|Ceil|Cos|Exp|Ln|Log|Round|Sin|Sqrt|Tan|RegExMatch|StrLen|Asc|getDataFromAPI|getDataFromJSON|float"



funcs_func .= "|HTpy"
functionNames .= "|HTpy"
awesdrtf := "|A" . Chr(95) . "LoopField|A" . Chr(95) . "Index"

willNextLineBeCurlyBracee := 0
theFuncWeFound := ""
theFuncWeFoundAllNames := ""
haveWeEverUsedAloop := 0
;OutputDebug, %HTpyCode%
Loop, Parse, HTpyCode, `n, `r
{

if (willNextLineBeCurlyBracee = 1)
{
; 123 is {
if (A_LoopField = Chr(123))
{
willNextLineBeCurlyBracee := 0

functionNames .= "|" . lastFuncName
;lastFuncFullName
theFuncWeFound .= lastFuncFullName . "`n"
theFuncWeFoundAllNames .= lastFuncName . Chr(40) . "`n"
}
}



if (SubStr(StrLower(A_LoopField), 1, 4) = CheckIFandElsesss1) or (SubStr(StrLower(A_LoopField), 1, 3) = CheckIFandElsesss2) or (SubStr(StrLower(A_LoopField), 1, 5) = CheckIFandElsesss3) or (SubStr(StrLower(A_LoopField), 1, 4) = CheckIFandElsesss4) or (SubStr(StrLower(A_LoopField), 1, 9) = CheckIFandElsesss5) or (SubStr(StrLower(A_LoopField), 1, 8) = CheckIFandElsesss6) or (SubStr(StrLower(A_LoopField), 1, 10) = CheckIFandElsesss7) or (SubStr(StrLower(A_LoopField), 1, 9) = CheckIFandElsesss8) or (SubStr(StrLower(A_LoopField), 1, 5) = "loop,")
{
; not a func
willNextLineBeCurlyBracee := 0
;OutputDebug, %A_LoopField%
}
else
{
;OutputDebug, ||%A_LoopField%||
strForCheckIfFunc := StrSplit(A_LoopField, Chr(40), 1)
;OutputDebug, |%strForCheckIfFunc%|
if (funcToChecIfVaidNameForFunc(Trim(strForCheckIfFunc))) && (strForCheckIfFunc != "") && (InStr(A_LoopField, Chr(40)))
{
willNextLineBeCurlyBracee := 1
lastFuncName := strForCheckIfFunc
lastFuncFullName := A_LoopField
;OutputDebug, %lastFuncFullName%
}
else
{
willNextLineBeCurlyBracee := 0

}

}


}


StringTrimRight, theFuncWeFound, theFuncWeFound, 1
StringTrimRight, theFuncWeFoundAllNames, theFuncWeFoundAllNames, 1
;OutputDebug, %theFuncWeFound%
;OutputDebug, %functionNames%
;OutputDebug, %theFuncWeFoundAllNames%


onceImportTime := 0
weUseRandomAtLeastOnce := 0
weEverUseVars := ""
usedLib := ""
putEndPointFlask1Up := ""
putEndPointFlask2Down := ""
AindexcharLength := 1
pycodeAcurlyBraceAddSomeVrasFixNL := 0
pycodeAcurlyBraceAddSomeVrasFixLP := 0
pycodeLoopfixa := ""

Loop, Parse, HTpyCode, `n, `r
{
lineDone := 0
if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower("msgbox, % "))
{
StringTrimLeft, var1, A_LoopField, 10


var2 := Trim(transpileVariables(var1, functionNames))



out := "print(" . var2 . ")"


lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower("msgbox, ")) && (SubStr(Trim(StrLower(A_LoopField)), 1, 10) != StrLower("msgbox, % "))
{
StringTrimLeft, var1, A_LoopField, 8

OUTvarMsgLow := transpileLowVariables(var1)
OUTvarMsgLow := StrReplace(OUTvarMsgLow, Chr(96), Chr(92))
out := "print(" . OUTvarMsgLow . ")"


lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "sort, ")
{
StringTrimLeft, str1, A_LoopField, 6

str1 := Trim(str1)
weHaveAcommaFixSortCommand := 0
if (SubStr(str1, 0) = Chr(44))
{
;MsgBox, comma YES
StringTrimRight, str1, str1, 1
weHaveAcommaFixSortCommand := 1
}
else
{
;MsgBox, comma NO
gg := 0
}

s := StrSplit(str1, ",", 1)
out1 := Trim(s)

s := StrSplit(str1, ",", 2)
out2 := Trim(s)

if (weHaveAcommaFixSortCommand = 1)
{
out2 := out2 . Chr(44)
}


var1 := "variables['" . out1 . "'] = SortLikeAHK(variables['" . out1 . "'], " . Chr(34) . out2 . Chr(34) . ")"
lineDone := 1
pyCode .= var1 . "`n"


}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = StrLower("Port, "))
{
StringTrimLeft, str1, A_LoopField, 6
str1 := Trim(transpileVariables(str1, functionNames))



var1 := "variables['port'] = " . str(str1)
port := "variables['port']"
lineDone := 1
pyCode .= var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower("Random, "))
{
varr1 := StrSplit(A_LoopField, ",", 2)
varr2 := StrSplit(A_LoopField, ",", 3)
varr3 := StrSplit(A_LoopField, ",", 4)

outt1 := Trim(transpileVariables(varr1, functionNames))
outt2 := Trim(transpileVariables(varr2, functionNames))
outt3 := Trim(transpileVariables(varr3, functionNames))
weUseRandomAtLeastOnce++
if (weUseRandomAtLeastOnce = 1)
{
usedLib .= "import random`n"
}
out := outt1 . " = " . "random.randint(" . outt2 . ", " . outt3 . ")"

lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 17) = StrLower("StringTrimRight, "))
{
varr1 := StrSplit(A_LoopField, ",", 2)
varr2 := StrSplit(A_LoopField, ",", 3)
varr3 := StrSplit(A_LoopField, ",", 4)

outt1 := Trim(transpileVariables(varr1, functionNames))
outt2 := Trim(transpileVariables(varr2, functionNames))
outt3 := Trim(transpileVariables(varr3, functionNames))

out := outt1 . " = " . "StringTrimRight(" . outt2 . ", " . outt3 . ")"

lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 16) = StrLower("StringTrimLeft, "))
{
varr1 := StrSplit(A_LoopField, ",", 2)
varr2 := StrSplit(A_LoopField, ",", 3)
varr3 := StrSplit(A_LoopField, ",", 4)

outt1 := Trim(transpileVariables(varr1, functionNames))
outt2 := Trim(transpileVariables(varr2, functionNames))
outt3 := Trim(transpileVariables(varr3, functionNames))

out := outt1 . " = " . "StringTrimLeft(" . outt2 . ", " . outt3 . ")"

lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 7) = StrLower("sleep, "))
{

StringTrimLeft, var1, A_LoopField, 7

var1 := Trim(transpileVariables(var1, functionNames))
out := "time.sleep(" . var1 . " / 1000" . ")"
lineDone := 1
onceImportTime++
if (onceImportTime = 1)
{
usedLib .= "import time`n"
}
pyCode .= out . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = "settimer, ")
{
StringTrimLeft, str1, A_LoopField, 10

str2 := Trim(StrSplit(str1, ",", 1))
str3 := Trim(StrSplit(str1, ",", 2))

if (StrLower(str3) = "on")
{
str3 := Chr(34) . "On" . Chr(34)
}

if (StrLower(str3) = "off")
{
str3 := Chr(34) . "Off" . Chr(34)
}

out1 := "SetTimer(" . str2 . ", " . str3 . ")"

lineDone := 1
pyCode .= out1 . "`n"
}
else if (Trim(StrLower(A_LoopField)) = "exitapp")
{

lineDone := 1
pyCode .= "ExitApp()" . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = "fileread, ")
{
StringTrimLeft, filereadCommand, A_LoopField, 10
filereadCommand1varname := StrSplit(filereadCommand, ", ", 1)
filereadCommand2path := StrSplit(filereadCommand, ", ", 2)

filereadCommand2path := StrReplace(filereadCommand2path, "\\", "\\\\")

filereadCommand2path := Trim(transpileLowVariables(filereadCommand2path))
filereadCommand1varname := Trim(transpileVariables(filereadCommand1varname, functionNames))
pyCode .= filereadCommand1varname . " = FileRead(" . filereadCommand2path . ")`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 12) = "fileappend, ")
{
StringTrimLeft, fileAppendCommand, A_LoopField, 12
fileAppendCommand1varname := StrSplit(fileAppendCommand, ", ", 1)
fileAppendCommand2path := StrSplit(fileAppendCommand, ", ", 2)

fileAppendCommand2path := StrReplace(fileAppendCommand2path, "\\", "\\\\")

fileAppendCommand1varname := Trim(transpileLowVariables(fileAppendCommand1varname))
fileAppendCommand2path := Trim(transpileLowVariables(fileAppendCommand2path))

pyCode .= "FileAppend(" . fileAppendCommand1varname . ", " . fileAppendCommand2path . ")`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 12) = "filedelete, ")
{
StringTrimLeft, fileDeleteCommand, A_LoopField, 12

fileDeleteCommand2path := StrSplit(fileDeleteCommand, ", ", 1)

fileDeleteCommand2path := StrReplace(fileDeleteCommand2path, "\\", "\\\\")
fileDeleteCommand2path := Trim(transpileLowVariables(fileDeleteCommand2path))


pyCode .= "FileDelete(" . fileDeleteCommand2path . ")`n"
lineDone := 1
}
else if (ifTheLineIsAFuncDec(Trim(A_LoopField), theFuncWeFound))
{

;OutputDebug, %A_LoopField%
str23IfFuncIn := A_LoopField
str23IfFuncInNAME := StrSplit(str23IfFuncIn, Chr(40), 1)




str23IfFuncIn := StrSplit(str23IfFuncIn, Chr(40), 2)
nothing := ""
str23IfFuncInALL := StrReplace(str23IfFuncIn, Chr(40), nothing)
str23IfFuncInALL := StrReplace(str23IfFuncInALL, Chr(41), nothing)
wasHereInfuncAndgetingVar1 := 0
theVarsPArmFormTheFunc := ""
if (str23IfFuncInALL != "")
{
Loop, Parse, str23IfFuncInALL, `,
{
wasHereInfuncAndgetingVar1 := 1
var1 := Trim(A_LoopField)
theVarsPArmFormTheFunc .= "variables['" . var1 . "'] = " . var1 . "`n"
}
}

skipLeftCuleyForFuncPLS := 0
if (str23IfFuncInALL != "")
{
str234567 := "def " . str23IfFuncInNAME . Chr(40) . str23IfFuncInALL . Chr(41) . ":`n{`n" . theVarsPArmFormTheFunc
skipLeftCuleyForFuncPLS := 1
}
else
{
str234567 := "def " . str23IfFuncInNAME . Chr(40) . str23IfFuncInALL . Chr(41) . ":"
}


Loop, % str23IfFuncInNAMEnum
{

if (str23IfFuncInNAME%A_Index% = str23IfFuncInNAME)
{
var12312 := ""
if (str23IfFuncInALL != "")
{
Loop, Parse, str23IfFuncInALL, `,
{
wasHereInfuncAndgetingVar1 := 1
var1 := Trim(A_LoopField)

var12312 .= transpileVariables(var1, functionNames) . ", "

}
StringTrimRight, var12312, var12312, 2
}


if (wasHereInfuncAndgetingVar1 = 0)
{
str2345678 := str23IfFuncInNAME . Chr(40) . Chr(41)
}
else
{
str2345678 := str23IfFuncInNAME . Chr(40) . var12312 . Chr(41)
}
lineDone := 1

}


}

str23IfFuncInNAMEnum++
str23IfFuncInNAME%str23IfFuncInNAMEnum% := str23IfFuncInNAME






if (lineDone = 1)
{
pyCode .= str2345678 . "`n"
}
else
{
lineDone := 1
pyCode .= str234567 . "`n"
}

}
else if (SubStr(Trim(A_LoopField), 1, 7) = "return ")
{

StringTrimLeft, strFormReturn, A_LoopField, 7

var12312 := transpileVariables(strFormReturn, functionNames)
out := "return " . var12312

lineDone := 1
pyCode .= out . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = "endpoint, ")
{

StringTrimLeft, strFormEndpoint, A_LoopField, 10

strFormEndpoint1 := Trim(StrSplit(strFormEndpoint, ",", 1))
strFormEndpoint2 := Trim(StrSplit(strFormEndpoint, ",", 2))


putEndPointFlask1Up := "from flask import Flask, send_file, request, jsonify`nimport os`nvariables = {}`napp = Flask(__name__)`n`n@app.route('/')`ndef app_route():`n    return send_file(os.path.join(os.path.dirname(__file__), 'index.html')), 200`n"

putEndPointFlask2Down := "`n@app.errorhandler(404)`ndef not_found(e):`n    return " . Chr(34) . "Page not found" . Chr(34) . ", 404`n`nif __name__ == '__main__':`n    app.run(host='0.0.0.0', port=" . str(port) . ", debug=True)"



firstLineVar1 := "@app.route('/" . strFormEndpoint2 . "', methods=['POST'])"
firstLineVar2 := "def " . strFormEndpoint2 . "():"
firstLineVar3 := "|variables['" . strFormEndpoint1 . "'] = request.get_json()"

out := firstLineVar1 . "`n" . firstLineVar2 . "`n" . firstLineVar3

lineDone := 1
pyCode .= out . "`n"

}
else if (StrLower(A_LoopField) = "loop")
{
; infinity loops
haveWeEverUsedAloop := 1
lineDone := 1
var1 := "for A" . Chr(95) . "Index" . str(AindexcharLength) . " , value in enumerate(iter(int, 1), start=1):"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing
theFixTextLoopNL := "variables['A" . Chr(95) . "Index" . str(AindexcharLength) . "'] = A" . Chr(95) . "Index" . str(AindexcharLength)

pycodeAcurlyBraceAddSomeVrasFixNL := 1
lineDone := 1
pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
pyCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "loop, ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 8) != "loop, % ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 7) != "loop % ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 11) != StrLower("Loop, Parse"))
{



str123 := A_LoopField
;MsgBox, % str123


StringTrimLeft, out2, str123, 6

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := transpileVariables(myVar, functionNames)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line
var1 := "for A" . Chr(95) . "Index" . str(AindexcharLength) . " in range(1, " . line . " + 1):"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing
theFixTextLoopNL := "variables['A" . Chr(95) . "Index" . str(AindexcharLength) . "'] = A" . Chr(95) . "Index" . str(AindexcharLength)

pycodeAcurlyBraceAddSomeVrasFixNL := 1

pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
lineDone := 1
pyCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = "loop, % ")
{
str123 := A_LoopField
;MsgBox, % str123


StringTrimLeft, out2, str123, 8

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := transpileVariables(myVar, functionNames)
line := lineYGI

;MsgBox, % line
var1 := "for A" . Chr(95) . "Index" . str(AindexcharLength) . " in range(1, " . line . " + 1):"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing
theFixTextLoopNL := "variables['A" . Chr(95) . "Index" . str(AindexcharLength) . "'] = A" . Chr(95) . "Index" . str(AindexcharLength)

pycodeAcurlyBraceAddSomeVrasFixNL := 1
haveWeEverUsedAloop := 1
pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
lineDone := 1
pyCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 13) = StrLower("Loop, Parse, "))
{

var1 := A_LoopField
lineDone := 1
var1 := Trim(var1)
StringTrimLeft, var1, var1, 13

line1 := Trim(StrSplit(var1, ",", 1))

line1 := transpileVariables(line1, functionNames)
line2 := ""
line3 := ""
itemsOut := ""
line2 := Trim(StrSplit(var1, ",", 2))
line3 := Trim(StrSplit(var1, ",", 3))



if (InStr(var1, Chr(96) . ","))
{
line2 := Chr(34) . "," . Chr(34)
itemsOut := "items = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
else
{



if (line2 = "") && (line3 = "")
{
; nothing so only each char
itemsOut := "items = LoopParseFunc(" . line1 . ")"
}

if (line2 != "") && (line3 = "")
{
if (InStr(line2, Chr(96)))
{
line2 := Chr(34) . line2 . Chr(34)
}
itemsOut := "items = LoopParseFunc(" . line1 . ", " . line2 . ")"
}

if (line2 != "") && (line3 != "")
{
if (InStr(line2, Chr(96)))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (InStr(line3, Chr(96)))
{
line3 := Chr(34) . line3 . Chr(34)
}

itemsOut := "items = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}



itemsOut := StrReplace(itemsOut, Chr(96), Chr(92))



}


var1out := itemsOut . "`n" . "for A" . Chr(95) . "Index" . str(AindexcharLength) . ", A" . Chr(95) . "LoopField" . str(AindexcharLength) . " in enumerate(items, start=1):"



nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing


theFixTextLoopLP := "variables['A" . Chr(95) . "Index" . str(AindexcharLength) . "'] = A" . Chr(95) . "Index" . str(AindexcharLength) . "`n" . "variables['A" . Chr(95) . "LoopField" . str(AindexcharLength) . "'] = A" . Chr(95) . "LoopField" . str(AindexcharLength)

pycodeAcurlyBraceAddSomeVrasFixLP := 1
haveWeEverUsedAloop := 1
pycodeLoopfixa .= "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
pyCode .= pycodeLoopfixa1 . "`n" . var1out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 7) = "gosub, ")
{

;MsgBox, % A_LoopField


sstr1 := A_LoopField

s := StrSplit(sstr1, ",", 2)
out1 := s

out1 := Trim(out1)

out2 := out1 . "()"

;MsgBox, % out2
lineDone := 1
pyCode .= out2 . "`n"

}
else if (A_LoopField == "Return")
{
pyCode .= "}" . "`n"
lineDone := 1
}
else if (RegExReplace(A_LoopField, "^\\w+:$", "") != A_LoopField) && (Trim(SubStr(A_LoopField, 0)) = ":") && (lineDone != 1)
{

;MsgBox, % A_LoopField



out1 := A_LoopField

out1 := Trim(out1)

StringTrimRight, out1, out1, 1



pyCode .= "def " . out1 . "():`n{`n"

;MsgBox, % out1
;~ MsgBox, % see

lineDone := 1
}
else if (SubStr(A_LoopField, -1) = "++")
{
str123 := Trim(A_LoopField)
StringTrimRight, str123, str123, 2

str123 := Trim(transpileVariables(str123, functionNames))

out := str123 . " += 1"
lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(A_LoopField, -1) = "--")
{
str123 := Trim(A_LoopField)
StringTrimRight, str123, str123, 2

str123 := Trim(transpileVariables(str123, functionNames))

out := str123 . " -= 1"
lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss1)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 3) = StrLower(CheckIFandElsesss2)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = StrLower(CheckIFandElsesss3)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss4)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss5)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower(CheckIFandElsesss6)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower(CheckIFandElsesss7)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss8))
{


if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss1))
{
CheckIFandElsesssNum := 4
CheckIFandElsesssNumNum := 1
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 3) = StrLower(CheckIFandElsesss2))
{
CheckIFandElsesssNum := 3
CheckIFandElsesssNumNum := 2
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = StrLower(CheckIFandElsesss3))
{
CheckIFandElsesssNum := 5
CheckIFandElsesssNumNum := 3
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss4))
{
CheckIFandElsesssNum := 4
CheckIFandElsesssNumNum := 4
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss5))
{
CheckIFandElsesssNum := 9
CheckIFandElsesssNumNum := 5
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower(CheckIFandElsesss6))
{
CheckIFandElsesssNum := 8
CheckIFandElsesssNumNum := 6
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower(CheckIFandElsesss7))
{
CheckIFandElsesssNum := 10
CheckIFandElsesssNumNum := 7
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss8))
{
CheckIFandElsesssNum := 9
CheckIFandElsesssNumNum := 8
}

StringTrimLeft, str123, A_LoopField, CheckIFandElsesssNum

str123 := CheckIFandElsesss%CheckIFandElsesssNumNum% . Chr(32) . transpileVariables(str123, functionNames)


if (SubStr(Trim(StrLower(str123)), 1, 7) = StrLower("else if"))
{
str123 := StrReplace(str123, "else if", "elif")
}
else
{
str123 := str123
StringTrimLeft, str123, str123, 2
str123 := "if" . str123
}


str123 := Trim(str123) . ":"

str123 := StrReplace(str123, "if " . Chr(40) . Chr(32), "if " . Chr(40))
str123 := StrReplace(str123, Chr(32) . Chr(41) . ":", Chr(41) . ":")


out := str123

lineDone := 1
pyCode .= out . "`n"
}
else if (StrLower(A_LoopField) = StrLower("else"))
{

out := "else:"

lineDone := 1
pyCode .= out . "`n"
}
else if (InStr(A_LoopField, " := ")) or (InStr(A_LoopField, " .= ")) or (InStr(A_LoopField, " += ")) or (InStr(A_LoopField, " -= ")) or (InStr(A_LoopField, " *= ")) && (lineDone = 0)
{
lineDone := 1
str123 := A_LoopField

whatVarWeUse := ""
if (InStr(A_LoopField, " := "))
{
whatVarWeUse := " = "
}
if (InStr(A_LoopField, " .= "))
{
whatVarWeUse := " += "
}
if (InStr(A_LoopField, " += "))
{
whatVarWeUse := " += "
}
if (InStr(A_LoopField, " -= "))
{
whatVarWeUse := " -= "
}
if (InStr(A_LoopField, " *= "))
{
whatVarWeUse := " *= "
}




str123 := StrReplace(str123, ":=", "=")
str123 := StrReplace(str123, ".=", "=")
str123 := StrReplace(str123, "+=", "=")
str123 := StrReplace(str123, "-=", "=")
str123 := StrReplace(str123, "*=", "=")


var1avavavavva := Trim(StrSplit(str123, "=", 1))
var2avavavavva := Trim(StrSplit(str123, "=", 2))
;OutputDebug, ||||||||||||%var2%||||||||||||

varOUT1avavavavva := transpileVariables(var1avavavavva, functionNames)
varOUT2avavavavva := transpileVariables(var2avavavavva, functionNames)


out := varOUT1avavavavva . whatVarWeUse . varOUT2avavavavva

lineDone := 1
pyCode .= out . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(59)) && (lineDone = 0)
{
StringTrimLeft, str123, A_LoopField, 1

str123 := "#" . str123
out := str123
lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 0) = Chr(41)) && (lineDone = 0)
{
str123 := A_LoopField
FuncNameWhatIsIt := StrSplit(str123, "(", 1)

Loop, Parse, FuncNameWhatIsIt
{
StringTrimLeft, str123, str123, 1
}

outVarTransiled := transpileVariables(str123, functionNames)



out := FuncNameWhatIsIt . outVarTransiled
lineDone := 1
pyCode .= out . "`n"
}
else
{
; this is THE else
if (lineDone != 1)
{
if (skipLeftCuleyForFuncPLS != 1)
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(125))
{
pyCode .= Chr(125) . "`n"
}
else
{
if (pycodeAcurlyBraceAddSomeVrasFixLP = 1) && (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
pycodeAcurlyBraceAddSomeVrasFixLP := 0


pyCode .= A_LoopField . "`n" . theFixTextLoopLP . "`n"
}
else
{
if (pycodeAcurlyBraceAddSomeVrasFixNL = 1) && (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
pycodeAcurlyBraceAddSomeVrasFixNL := 0
pyCode .= A_LoopField . "`n" . theFixTextLoopNL . "`n"
}
else
{
pyCode .= A_LoopField . "`n"
}
}
}
}
else
{
skipLeftCuleyForFuncPLS := 0
}
}
}

} ; end of the parsing loop














































if (haveWeEverUsedAloop = 1)
{

StringTrimRight, pycodeLoopfixa, pycodeLoopfixa, 1

;OutputDebug, |%pycodeLoopfixa%|
AIndexLoopCurlyFix := 1
Loop, Parse, pycodeLoopfixa, `n, `r
{



str123 := A_LoopField
fixLoopLokingFor := A_LoopField
fixLoopLokingForfound := 1
out1 := StrSplit(str123 ,"|" , 1)
out2 := StrSplit(str123 ,"|" , 3)
;OutputDebug, |%out1%|
;OutputDebug, |%out2%|



wasAtanyIfsElseAddAIndexLoopCurlyFix := 0


if (out1 = "nl")
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a%AIndexLoopCurlyFix% := ""
Loop, Parse, pyCode, `n, `r
{
;MsgBox, dsfgsdefgesrdg1
;MsgBox, |%A_LoopField%|`n|%fixLoopLokingFor%|


if (InStr(A_LoopField, fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1

;MsgBox, do we came here 1
}

if (InStr(A_LoopField, "for ")) && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{

s := StrSplit(A_LoopField ,"A" . Chr(95) . "Index", 2)
out1z := s


s := StrSplit(out1z, " ", 1)
out1z := Trim(s)


;MsgBox, % out1z

;MsgBox, do we came here 2
fixLoopLokingForNum := 0
foundTheTopLoop++
  inTarget := 1
	;MsgBox, % A_LoopField
	dontSaveStr := 1

	ALoopField := A_LoopField

	;ALoopField := StrReplace(ALoopField, "for (/* Loop parse */", "for (/* Loop parse */ /* From AHK */")
DeleayOneCuzOfLoopParse := 1
	out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (InStr(A_LoopField, "for ")) && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}

out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField




; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "Index(?:\\d+)?", "A" . Chr(95) . "Index" . out1z)



;ALoopField := StrReplace(ALoopField, "A_LoopField", "A_LoopField" . AIndexLoopCurlyFix)


out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{
out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
 insdeAnestedLoopBAD := 0
}


}
strstysrstsytTRIMHELP := out4758686d86d86d86578991a%AIndexLoopCurlyFix%
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1
;MsgBox, % out4758686d86d86d86578991a%AIndexLoopCurlyFix%


pyCode := strstysrstsytTRIMHELP

;MsgBox, % jsCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}
else
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a%AIndexLoopCurlyFix% := ""
Loop, Parse, pyCode, `n, `r
{

if (InStr(A_LoopField , fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1
;MsgBox, do we came here 3
}

if (InStr(A_LoopField , "for ")) && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{


s := StrSplit(A_LoopField ,"A" . Chr(95) . "LoopField", 2)
out1z := s

s := StrSplit(out1z, " ", 1)
out1z := Trim(s)

;MsgBox, % out1z

fixLoopLokingForNum := 0
;MsgBox, do we came here 4
foundTheTopLoop++
  inTarget := 1
	;MsgBox, % A_LoopField
	dontSaveStr := 1

	ALoopField := A_LoopField

	;ALoopField := StrReplace(ALoopField, "for (/* Loop parse */", "for (/* Loop parse */ /* From AHK */")
DeleayOneCuzOfLoopParse := 1
	out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (InStr(A_LoopField, "for ")) && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}


out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField


; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "Index(?:\\d+)?", "A" . Chr(95) . "Index" . out1z)
; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "LoopField(?:\\d+)?", "A" . Chr(95) . "LoopField" . out1z)





out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{
out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
 insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a%AIndexLoopCurlyFix%
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1
;MsgBox, % out4758686d86d86d86578991a%AIndexLoopCurlyFix%


pyCode := strstysrstsytTRIMHELP

;MsgBox, % jsCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}

if (wasAtanyIfsElseAddAIndexLoopCurlyFix = 1)
{
AIndexLoopCurlyFix++
wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
}
}


out4758686d86dgt8r754444444 := ""
hold := 0
Loop, Parse, pyCode, `n, `r
{
ignore := 0
if (InStr(A_LoopField, "for "))
{
if (hold = 1) && (holdText = A_LoopField)
{
ignore := 1
}
else
{
holdText := A_LoopField
hold := 1
}
}

if (!(ignore))
{
out4758686d86dgt8r754444444 .= A_LoopField . "`n"
}
}

StringTrimRight, out4758686d86dgt8r754444444, out4758686d86dgt8r754444444, 1
pyCode := out4758686d86dgt8r754444444


}





pyCode := indent_nested_curly_braces(pyCode)


































pyCodeOut1234565432 := ""
Loop, Parse, pyCode, `n, `r
{

if (Trim(A_LoopField) != Chr(123)) && (Trim(A_LoopField) != Chr(125))
{
out := A_LoopField

StringTrimLeft, out, out, 1

if (InStr(out, "variables['A" . Chr(95) . "Index")) or (InStr(out, "variables['A" . Chr(95) . "LoopField"))
{

out := StrReplace(out, Chr(39) . Chr(34) . Chr(93) . Chr(125) . Chr(39) . Chr(93), Chr(34) . Chr(93) . Chr(125) . Chr(39) . Chr(93))
out := StrReplace(out, Chr(39) . Chr(39) . Chr(93), Chr(39) . Chr(93))
}

if (!(InStr(out, "|itsaersdtgtgfergsdgfsegdfsedAA|")))
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) != Chr(59))
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(124))
{
nothing := ""
out := StrReplace(out, "|", nothing)
pyCodeOut1234565432 .= Chr(32) . Chr(32) . Chr(32) . Chr(32) . out . "`n"
}
else
{
pyCodeOut1234565432 .= out . "`n"
}
}
}


}

}


StringTrimRight, pyCode, pyCodeOut1234565432, 1



pyCodeOutOneLastFix := ""
Loop, Parse, pyCode, `n, `r
{

sstr1 := A_LoopField

sstr1 := StrReplace(sstr1, "variables['A_TickCount']", "BuildInVars(" . Chr(34) . "A_TickCount" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_Now']", "BuildInVars(" . Chr(34) . "A_Now" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_YYYY']", "BuildInVars(" . Chr(34) . "A_YYYY" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_MMMM']", "BuildInVars(" . Chr(34) . "A_MMMM" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_MMM']", "BuildInVars(" . Chr(34) . "A_MMM" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_MM']", "BuildInVars(" . Chr(34) . "A_MM" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_DDDD']", "BuildInVars(" . Chr(34) . "A_DDDD" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_DDD']", "BuildInVars(" . Chr(34) . "A_DDD" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_DD']", "BuildInVars(" . Chr(34) . "A_DD" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_Hour']", "BuildInVars(" . Chr(34) . "A_Hour" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_Min']", "BuildInVars(" . Chr(34) . "A_Min" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_Sec']", "BuildInVars(" . Chr(34) . "A_Sec" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_Space']", "BuildInVars(" . Chr(34) . "A_Space" . Chr(34) . ")")
sstr1 := StrReplace(sstr1, "variables['A_Tab']", "BuildInVars(" . Chr(34) . "A_Tab" . Chr(34) . ")")


pyCodeOutOneLastFix .= sstr1 . "`n"

}
StringTrimRight, pyCode, pyCodeOutOneLastFix, 1



pyCodeFinal := pyCode



allFuncsHere := ""
Loop, Parse, funcs_func, "|"
{
if (InStr(pyCodeFinal, A_LoopField . Chr(40)))
{
hererererehre := A_LoopField . "_func"
allFuncsHere .= func_%hererererehre%
}
}

pyCodeFinal := allFuncsHere . "`n" . pyCodeFinal . "`n"

if (usedLib = "")
{
pyCode := weEverUseVars . "`n" . pyCodeFinal

if (weEverUseVars = "")
{
pyCode := pyCodeFinal
}
else
{
pyCode := weEverUseVars . "`n" . pyCodeFinal
}

}
else
{
pyCode := usedLib . "`n" . weEverUseVars . "`n" . pyCodeFinal
}




pyCode := StrReplace(pyCode, "`n`n", "`n")


if (putEndPointFlask1Up != "")
{
pyCode := putEndPointFlask1Up . "`n" . pyCode . "`n" . putEndPointFlask2Down . "`n"
}



Loop, % theIdNumOfThe34
{
pyCode := StrReplace(pyCode, "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . str(A_Index) . Chr(65) . Chr(65), theIdNumOfThe34theVar%A_Index%)
}



return pyCode

}

HTpy()
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;

