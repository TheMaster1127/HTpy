; HTpy

Gui, Font, s18
Gui, Show, +websiteMode w%A_ScreenWidth% h%A_ScreenHeight%

if (isMobileDevice())
{
WidthOfBoxes := (A_ScreenWidth) - 20
editBoxX := (A_ScreenWidth - WidthOfBoxes) / 2
editH1 := A_ScreenHeight - 10
editBoxY1 := (A_ScreenHeight - editH1) / 2
editBoxY2 := (A_ScreenHeight / 2) + 65


editH1 := (A_ScreenHeight / 2)
editH2 := editH1 - 70

editBoxX := 10
editBoxX2 := 10
Gui, Add, Edit, x%editBoxX% y%editBoxY1% w%WidthOfBoxes% h%editH1% veditBox gCodeTextEditBox cffffff bg303030, put or type your HTpy code here...
Gui, Add, Edit, x%editBoxX2% y%editBoxY2% w%WidthOfBoxes% h%editH2% vcodeBox bg303030 cffffff
eval("Gui1codeBox.setReadOnly(true);")
eval("Gui1editBox.setBehavioursEnabled(false);")


sendButtonX := (A_ScreenWidth - 140) / 2
sendButtonY := editBoxY2 - 60
Gui, Add, Button, x%sendButtonX% y%sendButtonY% w140 h40 gButton vButtonID, Transpile

GuiControl, Focus, editBox

oldA_ScreenWidth := A_ScreenWidth
oldA_ScreenHeight := A_ScreenHeight
}
else
{

WidthOfBoxes := (A_ScreenWidth / 2) - 20
editBoxX := (A_ScreenWidth - WidthOfBoxes) / 2
editH1 := A_ScreenHeight - 10
editBoxY := (A_ScreenHeight - editH1) / 2

editH1 := A_ScreenHeight - 60
editH2 := editH1

editBoxX := 10
editBoxX2 := WidthOfBoxes + 25
Gui, Add, Edit, x%editBoxX% y%editBoxY% w%WidthOfBoxes% h%editH1% veditBox gCodeTextEditBox cffffff bg303030, put or type your HTpy code here...
Gui, Add, Edit, x%editBoxX2% y%editBoxY% w%WidthOfBoxes% h%editH2% vcodeBox bg303030 cffffff
eval("Gui1codeBox.setReadOnly(true);")
eval("Gui1editBox.setBehavioursEnabled(false);")


sendButtonX := (A_ScreenWidth - 140) / 2
sendButtonY := (A_ScreenHeight - 40) - 10
Gui, Add, Button, x%sendButtonX% y%sendButtonY% w140 h40 gButton vButtonID, Transpile

GuiControl, Focus, editBox

oldA_ScreenWidth := A_ScreenWidth
oldA_ScreenHeight := A_ScreenHeight
SetTimer, onScreenSizeChange, 100
}

return

onScreenSizeChange:
if (oldA_ScreenWidth != A_ScreenWidth) or (oldA_ScreenHeight != A_ScreenHeight)
{

WidthOfBoxes := (A_ScreenWidth / 2) - 20

editBoxX := (A_ScreenWidth - WidthOfBoxes) / 2
editH1 := A_ScreenHeight - 100
editBoxY := (A_ScreenHeight - editH1) / 2

editH1 := A_ScreenHeight - 120
editH2 := editH1

editBoxX := 10
editBoxX2 := WidthOfBoxes + 25
GuiControl, Move, editBox, x%editBoxX% y%editBoxY% w%WidthOfBoxes% h%editH1%
GuiControl, Move, codeBox, x%editBoxX2% y%editBoxY% w%WidthOfBoxes% h%editH2%
eval("Gui1codeBox.readOnly = true;")

sendButtonX := (A_ScreenWidth - 140) / 2
sendButtonY := (A_ScreenHeight - 40) - 10
GuiControl, Move, ButtonID, x%sendButtonX% y%sendButtonY% w140 h40

GuiControl, Focus, editBox
oldA_ScreenWidth := A_ScreenWidth
oldA_ScreenHeight := A_ScreenHeight
}
Return

CodeTextEditBox:
HTpyCode := A_GuiControl
gosub, Button
Return

;here;here;here;here;here;here;here;here;here;here;here;here;here;here;here;here

^Enter::
gosub, Button
Return

^V::
Sleep, 111
gosub, Button
Return

; the compiler
Button:

pyCode := ""
out := ""
HTpyCodeD1 := ""

eavbnsalvbaslv := 0
Loop, Parse, HTpyCode, `n, `r
{
if (A_Index = 1)
{
HTpyCodeD1 .= Trim(A_LoopField) . "`n"
}
else
{

if (Trim(A_LoopField) = Chr(123)) && (eavbnsalvbaslv = 1)
{
; nothing
}
else
{
HTpyCodeD1 .= Trim(A_LoopField) . "`n"
}

eavbnsalvbaslv := 0
if (Trim(A_LoopField) = "")
{
eavbnsalvbaslv := 1
}


}



}
StringTrimRight, HTpyCode, HTpyCodeD1, 1




str23IfFuncInNAMEnum := 0

CheckIFandElsesss1 := "if ("
CheckIFandElsesss2 := "if("
CheckIFandElsesss3 := "if !("
CheckIFandElsesss4 := "if!("
CheckIFandElsesss5 := "else if ("
CheckIFandElsesss6 := "else if("
CheckIFandElsesss7 := "else if !("
CheckIFandElsesss8 := "else if!("
CheckIFandElsesssNum := 0

functionNames := "input|int|chr|str"

willNextLineBeCurlyBracee := 0
theFuncWeFound := ""
theFuncWeFoundAllNames := ""
;OutputDebug, %HTpyCode%
Loop, Parse, HTpyCode, `n, `r
{

if (willNextLineBeCurlyBracee = 1)
{
; 123 is {
if (A_LoopField = Chr(123))
{
willNextLineBeCurlyBracee := 0

functionNames .= "|" . lastFuncName
;lastFuncFullName
theFuncWeFound .= lastFuncFullName . "`n"
theFuncWeFoundAllNames .= lastFuncName . Chr(40) . "`n"
}
}



if (SubStr(StrLower(A_LoopField), 1, 4) = CheckIFandElsesss1) or (SubStr(StrLower(A_LoopField), 1, 3) = CheckIFandElsesss2) or (SubStr(StrLower(A_LoopField), 1, 5) = CheckIFandElsesss3) or (SubStr(StrLower(A_LoopField), 1, 4) = CheckIFandElsesss4) or (SubStr(StrLower(A_LoopField), 1, 9) = CheckIFandElsesss5) or (SubStr(StrLower(A_LoopField), 1, 8) = CheckIFandElsesss6) or (SubStr(StrLower(A_LoopField), 1, 10) = CheckIFandElsesss7) or (SubStr(StrLower(A_LoopField), 1, 9) = CheckIFandElsesss8) or (SubStr(StrLower(A_LoopField), 1, 5) = "loop,")
{
; not a func
willNextLineBeCurlyBracee := 0
;OutputDebug, %A_LoopField%
}
else
{
;OutputDebug, ||%A_LoopField%||
strForCheckIfFunc := StrSplit(A_LoopField, Chr(40), 1)
;OutputDebug, |%strForCheckIfFunc%|
if (funcToChecIfVaidNameForFunc(Trim(strForCheckIfFunc))) && (strForCheckIfFunc != "") && (InStr(A_LoopField, Chr(40)))
{
willNextLineBeCurlyBracee := 1
lastFuncName := strForCheckIfFunc
lastFuncFullName := A_LoopField
;OutputDebug, %lastFuncFullName%
}
else
{
willNextLineBeCurlyBracee := 0

}

}


}


StringTrimRight, theFuncWeFound, theFuncWeFound, 1
StringTrimRight, theFuncWeFoundAllNames, theFuncWeFoundAllNames, 1
;OutputDebug, %theFuncWeFound%
;OutputDebug, %functionNames%
;OutputDebug, %theFuncWeFoundAllNames%


onceImportTime := 0
weUseRandomAtLeastOnce := 0
weEverUseVars := ""
usedLib := ""
AindexcharLength := 1
pycodeLoopfixa := ""

Loop, Parse, HTpyCode, `n, `r
{
lineDone := 0
if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower("msgbox, % "))
{
StringTrimLeft, var1, A_LoopField, 10


var2 := Trim(transpileVariables(var1, functionNames))



out := "print(" . var2 . ")"


lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower("msgbox, ")) && (lineDone = 0)
{
StringTrimLeft, var1, A_LoopField, 8

OUTvarMsgLow := transpileLowVariables(var1)

out := "print(" . OUTvarMsgLow . ")"


lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower("Random, "))
{
varr1 := StrSplit(A_LoopField, ",", 2)
varr2 := StrSplit(A_LoopField, ",", 3)
varr3 := StrSplit(A_LoopField, ",", 4)

outt1 := Trim(transpileVariables(varr1, functionNames))
outt2 := Trim(transpileVariables(varr2, functionNames))
outt3 := Trim(transpileVariables(varr3, functionNames))
weUseRandomAtLeastOnce++
if (weUseRandomAtLeastOnce = 1)
{
usedLib .= "import random`n"
}
out := outt1 . " = " . "random.randint(" . outt2 . ", " . outt3 . ")"

lineDone := 1
pyCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 7) = StrLower("sleep, "))
{

StringTrimLeft, var1, A_LoopField, 7

var1 := Trim(transpileVariables(var1, functionNames))
out := "time.sleep(" . var1 . " / 1000" . ")"
lineDone := 1
onceImportTime++
if (onceImportTime = 1)
{
usedLib .= "import time`n"
}
pyCode .= out . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = StrLower("Loop,s"))
{

var1 := A_LoopField
StringTrimLeft, var1, var1, 6
var1 := Trim(transpileVariables(var1, functionNames))



out := "for variables['A" . Chr(95) . "Index'] in range(1, " . var1 . " + 1):"



lineDone := 1
pyCode .= out . "`n"
}
else if (ifTheLineIsAFuncDec(Trim(A_LoopField), theFuncWeFound))
{

OutputDebug, %A_LoopField%
str23IfFuncIn := A_LoopField
str23IfFuncInNAME := StrSplit(str23IfFuncIn, Chr(40), 1)




str23IfFuncIn := StrSplit(str23IfFuncIn, Chr(40), 2)
nothing := ""
str23IfFuncInALL := StrReplace(str23IfFuncIn, Chr(40), nothing)
str23IfFuncInALL := StrReplace(str23IfFuncInALL, Chr(41), nothing)
wasHereInfuncAndgetingVar1 := 0
theVarsPArmFormTheFunc := ""
if (str23IfFuncInALL != "")
{
Loop, Parse, str23IfFuncInALL, `,
{
wasHereInfuncAndgetingVar1 := 1
var1 := Trim(A_LoopField)
theVarsPArmFormTheFunc .= "variables['" . var1 . "'] = " . var1 . "`n"
}
}

skipLeftCuleyForFuncPLS := 0
if (str23IfFuncInALL != "")
{
str234567 := "def " . str23IfFuncInNAME . Chr(40) . str23IfFuncInALL . Chr(41) . ":`n{`n" . theVarsPArmFormTheFunc
skipLeftCuleyForFuncPLS := 1
}
else
{
str234567 := "def " . str23IfFuncInNAME . Chr(40) . str23IfFuncInALL . Chr(41) . ":"
}


Loop, %str23IfFuncInNAMEnum%
{

if (str23IfFuncInNAME%A_Index% = str23IfFuncInNAME)
{
var12312 := ""
if (str23IfFuncInALL != "")
{
Loop, Parse, str23IfFuncInALL, `,
{
wasHereInfuncAndgetingVar1 := 1
var1 := Trim(A_LoopField)

var12312 .= transpileVariables(var1, functionNames) . ", "

}
StringTrimRight, var12312, var12312, 2
}


if (wasHereInfuncAndgetingVar1 = 0)
{
str2345678 := str23IfFuncInNAME . Chr(40) . Chr(41)
}
else
{
str2345678 := str23IfFuncInNAME . Chr(40) . var12312 . Chr(41)
}
lineDone := 1

}


}

str23IfFuncInNAMEnum++
str23IfFuncInNAME%str23IfFuncInNAMEnum% := str23IfFuncInNAME






if (lineDone = 1)
{
pyCode .= str2345678 . "`n"
}
else
{
lineDone := 1
pyCode .= str234567 . "`n"
}

}
else if (SubStr(Trim(A_LoopField), 1, 7) = "return ")
{

StringTrimLeft, strFormReturn, A_LoopField, 7

var12312 := transpileVariables(strFormReturn, functionNames)
out := "return " . var12312

lineDone := 1
pyCode .= out . "`n"

}
else if (StrLower(A_LoopField) = "loop")
{
; infinity loops

lineDone := 1
var1 := "for A" . Chr(95) . "Index" . AindexcharLength . ", value in enumerate(iter(int, 1), start=1):"

lineDone := 1
pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . AindexcharLength . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . AindexcharLength
AindexcharLength++
pyCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "loop, ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 8) != "loop, % ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 7) != "loop % ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 11) != StrLower("Loop, Parse"))
{



str := A_LoopField
;MsgBox, % str


StringTrimLeft, out2, str, 6

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := transpileVariables(myVar, functionNames)
line := lineYGI

;MsgBox, % line
var1 := "for variables['A" . Chr(95) . "Index" . AindexcharLength . "'] in range(1, " . line . " + 1):"

pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . AindexcharLength . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . AindexcharLength
AindexcharLength++
lineDone := 1
pyCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = "loop, % ")
{
str := A_LoopField
;MsgBox, % str


StringTrimLeft, out2, str, 8

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := transpileVariables(myVar, functionNames)
line := lineYGI

;MsgBox, % line
var1 := "for variables['A" . Chr(95) . "Index" . AindexcharLength . "'] in range(1, " . line . " + 1):"

pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . AindexcharLength . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . AindexcharLength
AindexcharLength++
lineDone := 1
pyCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 13) = StrLower("Loop, Parse, "))
{

var1 := A_LoopField
lineDone := 1
var1 := Trim(var1)
StringTrimLeft, var1, var1, 13

line1 := Trim(StrSplit(var1, ",", 1))

line1 := transpileVariables(line1, functionNames)
line2 := ""
line3 := ""
itemsOut := ""
line2 := Trim(StrSplit(var1, ",", 2))
line3 := Trim(StrSplit(var1, ",", 3))

line2 := StrReplace(line2, Chr(96), Chr(92))
line3 := StrReplace(line3, Chr(96), Chr(92))


if (InStr(var1, Chr(96) . ","))
{
line2 := Chr(34) . "," . Chr(34)
itemsOut := "items = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
else
{

if (!(InStr(line2, Chr(34))))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (!(InStr(line3, Chr(34))))
{
line3 := Chr(34) . line3 . Chr(34)
}

if (line2 = "") && (line3 = "")
{
; nothing so only each char
itemsOut := "items = LoopParseFunc(" . line1 . ")"
}

if (line2 != "") && (line3 = "")
{
itemsOut := "items = LoopParseFunc(" . line1 . ", " . line2 . ")"
}

if (line2 != "") && (line3 != "")
{
itemsOut := "items = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}



}


var1out := itemsOut . "`n" . "for variables['A" . Chr(95) . "Index" . AindexcharLength . "'], variables['A" . Chr(95) . "LoopField" . AindexcharLength . "'] in enumerate(items, start=1):"
pycodeLoopfixa .= "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . AindexcharLength . "`n"
pycodeLoopfixa1 := "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . AindexcharLength
AindexcharLength++
pyCode .= pycodeLoopfixa1 . "`n" . var1out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss1)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 3) = StrLower(CheckIFandElsesss2)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = StrLower(CheckIFandElsesss3)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss4)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss5)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower(CheckIFandElsesss6)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower(CheckIFandElsesss7)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss8))
{


if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss1))
{
CheckIFandElsesssNum := 4
CheckIFandElsesssNumNum := 1
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 3) = StrLower(CheckIFandElsesss2))
{
CheckIFandElsesssNum := 3
CheckIFandElsesssNumNum := 2
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = StrLower(CheckIFandElsesss3))
{
CheckIFandElsesssNum := 5
CheckIFandElsesssNumNum := 3
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss4))
{
CheckIFandElsesssNum := 4
CheckIFandElsesssNumNum := 4
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss5))
{
CheckIFandElsesssNum := 9
CheckIFandElsesssNumNum := 5
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower(CheckIFandElsesss6))
{
CheckIFandElsesssNum := 8
CheckIFandElsesssNumNum := 6
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower(CheckIFandElsesss7))
{
CheckIFandElsesssNum := 10
CheckIFandElsesssNumNum := 7
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss8))
{
CheckIFandElsesssNum := 9
CheckIFandElsesssNumNum := 8
}

StringTrimLeft, str, A_LoopField, variables.CheckIFandElsesssNum

str := CheckIFandElsesss%CheckIFandElsesssNumNum% . A_Space . transpileVariables(str, functionNames)


if (SubStr(Trim(StrLower(str)), 1, 7) = StrLower("else if"))
{
str := StrReplace(str, "else if", "elif")
}
else
{
str := str
StringTrimLeft, str, str, 2
str := "if" . str
}


str := Trim(str) . ":"

str := StrReplace(str, "if " . Chr(40) . A_Space, "if " . Chr(40))
str := StrReplace(str, A_Space . Chr(41) . ":", Chr(41) . ":")


out := str

out := StrReplace(out, "!", " not ")
out := StrReplace(out, "  not ", " not ")

lineDone := 1
pyCode .= out . "`n"
}
else if (StrLower(A_LoopField) = StrLower("else"))
{

out := "else:"

lineDone := 1
pyCode .= out . "`n"
}
else if (InStr(A_LoopField, " := ")) or (InStr(A_LoopField, " .= ")) or (InStr(A_LoopField, " += ")) or (InStr(A_LoopField, " -= ")) or (InStr(A_LoopField, " *= ")) && (lineDone = 0)
{
lineDone := 1
str := A_LoopField

whatVarWeUse := ""
if (InStr(A_LoopField, " := "))
{
whatVarWeUse := " = "
}
if (InStr(A_LoopField, " .= "))
{
whatVarWeUse := " += "
}
if (InStr(A_LoopField, " += "))
{
whatVarWeUse := " += "
}
if (InStr(A_LoopField, " -= "))
{
whatVarWeUse := " -= "
}
if (InStr(A_LoopField, " *= "))
{
whatVarWeUse := " *= "
}




str := StrReplace(str, ":=", "=")
str := StrReplace(str, ".=", "=")
str := StrReplace(str, "+=", "=")
str := StrReplace(str, "-=", "=")
str := StrReplace(str, "*=", "=")


var1 := Trim(StrSplit(str, "=", 1))
var2 := Trim(StrSplit(str, "=", 2))
;OutputDebug, ||||||||||||%var2%||||||||||||
varOUT1 := transpileVariables(var1, functionNames)
varOUT2 := transpileVariables(var2, functionNames)


out := varOUT1 . whatVarWeUse . varOUT2


pyCode .= out . "`n"

}
else
{
if (lineDone != 1)
{
if (skipLeftCuleyForFuncPLS != 1)
{
pyCode .= A_LoopField . "`n"
}
else
{
skipLeftCuleyForFuncPLS := 0
}
}
}

} ; end of the parsing loop




















































StringTrimRight, pycodeLoopfixa, pycodeLoopfixa, 1

OutputDebug, |%pycodeLoopfixa%|
AIndexLoopCurlyFix := 1
Loop, Parse, pycodeLoopfixa, `n, `r
{



str123 := A_LoopField
fixLoopLokingFor := A_LoopField
fixLoopLokingForfound := 1
out1 := StrSplit(str123 ,"|" , 1)
out2 := StrSplit(str123 ,"|" , 3)
OutputDebug, |%out1%|
OutputDebug, |%out2%|



wasAtanyIfsElseAddAIndexLoopCurlyFix := 0


if (out1 = "nl")
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a%AIndexLoopCurlyFix% := ""
Loop, Parse, pyCode, `n, `r
{
;MsgBox, dsfgsdefgesrdg1
;MsgBox, |%A_LoopField%|`n|%fixLoopLokingFor%|


if (InStr(A_LoopField, fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1

;MsgBox, do we came here 1
}

if (InStr(A_LoopField, "for ")) && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{

s := StrSplit(A_LoopField ,"A" . Chr(95) . "Index", 2)
out1z := s

s := StrSplit(out1z, " ", 1)
out1z := Trim(s)

;MsgBox, % out1z

;MsgBox, do we came here 2
fixLoopLokingForNum := 0
foundTheTopLoop++
  inTarget := 1
	;MsgBox, % A_LoopField
	dontSaveStr := 1

	ALoopField := A_LoopField

	;ALoopField := StrReplace(ALoopField, "for (/* Loop parse */", "for (/* Loop parse */ /* From AHK */")
DeleayOneCuzOfLoopParse := 1
	out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (InStr(A_LoopField, "for ")) && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}

out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField




; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "Index(?:\\d+)?", "A" . Chr(95) . "Index" . out1z)



;ALoopField := StrReplace(ALoopField, "A_LoopField", "A_LoopField" . AIndexLoopCurlyFix)


out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{
out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
 insdeAnestedLoopBAD := 0
}


}
strstysrstsytTRIMHELP := out4758686d86d86d86578991a%AIndexLoopCurlyFix%
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1
;MsgBox, % out4758686d86d86d86578991a%AIndexLoopCurlyFix%


pyCode := strstysrstsytTRIMHELP

;MsgBox, % jsCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}
else
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a%AIndexLoopCurlyFix% := ""
Loop, Parse, pyCode, `n, `r
{

if (InStr(A_LoopField , fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1
;MsgBox, do we came here 3
}

if (InStr(A_LoopField , "for ")) && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{


s := StrSplit(A_LoopField ,"A" . Chr(95) . "Index", 2)
out1z := s

s := StrSplit(out1z, " ", 1)
out1z := Trim(s)

;MsgBox, % out1z

fixLoopLokingForNum := 0
;MsgBox, do we came here 4
foundTheTopLoop++
  inTarget := 1
	;MsgBox, % A_LoopField
	dontSaveStr := 1

	ALoopField := A_LoopField

	;ALoopField := StrReplace(ALoopField, "for (/* Loop parse */", "for (/* Loop parse */ /* From AHK */")
DeleayOneCuzOfLoopParse := 1
	out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (InStr(A_LoopField, "for ")) && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}


out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField


; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "Index(?:\\d+)?", "A" . Chr(95) . "Index" . out1z)
; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "LoopField(?:\\d+)?", "A" . Chr(95) . "LoopField" . out1z)





out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{
out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
 insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a%AIndexLoopCurlyFix%
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1
;MsgBox, % out4758686d86d86d86578991a%AIndexLoopCurlyFix%


pyCode := strstysrstsytTRIMHELP

;MsgBox, % jsCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}

if (wasAtanyIfsElseAddAIndexLoopCurlyFix = 1)
{
AIndexLoopCurlyFix++
wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
}
}


out4758686d86dgt8r754444444 := ""
hold := 0
Loop, Parse, pyCode, `n, `r
{
ignore := 0
if (InStr(A_LoopField, "for "))
{
if (hold = 1) && (holdText = A_LoopField)
{
ignore := 1
}
else
{
holdText := A_LoopField
hold := 1
}
}

if (!(ignore))
{
out4758686d86dgt8r754444444 .= A_LoopField . "`n"
}
}

StringTrimRight, out4758686d86dgt8r754444444, out4758686d86dgt8r754444444, 1
pyCode := out4758686d86dgt8r754444444








pyCode := indent_nested_curly_braces(pyCode)


































pyCodeOut1234565432 := ""
Loop, Parse, pyCode, `n, `r
{

if (Trim(A_LoopField) != Chr(123)) && (Trim(A_LoopField) != Chr(125))
{
out := A_LoopField

StringTrimLeft, out, out, 1

if (InStr(out, "variables['A" . Chr(95) . "Index")) or (InStr(out, "variables['A" . Chr(95) . "LoopField"))
{
out := StrReplace(out, ",']", "']")
out := StrReplace(out, "'],']", "']")
out := StrReplace(out, "']']", "']")
}

if (!(InStr(out, "|itsaersdtgtgfergsdgfsegdfsedAA|")))
{
pyCodeOut1234565432 .= out . "`n"
}


}

}

StringTrimRight, pyCode, pyCodeOut1234565432, 1
pyCodeFinal := pyCode
;~ FileRead, upCode, upCode.txt
;~ FileRead, downCode, downCode.txt
;~ pyCode := upCode . "`n" . usedLib . "`n" . weEverUseVars . "`n" . pyCode . "`n" . downCode

allFuncsHere := ""
Loop, Parse, funcs_func, "|"
{
if (InStr(pyCodeFinal, A_LoopField . Chr(40)))
{
hererererehre := A_LoopField . "_func"
allFuncsHere .= func_%hererererehre%
}
}

pyCodeFinal := allFuncsHere . "`n" . pyCodeFinal . "`n"

if (usedLib = "")
{
pyCode := weEverUseVars . "`n" . pyCodeFinal

if (weEverUseVars = "")
{
pyCode := pyCodeFinal
}
else
{
pyCode := weEverUseVars . "`n" . pyCodeFinal
}

}
else
{
pyCode := usedLib . "`n" . weEverUseVars . "`n" . pyCodeFinal
}




pyCode := StrReplace(pyCode, "`n`n", "`n")



eval("Gui1codeBox.session.setValue(variables.pyCode);")

Return
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;


indent_nested_curly_braces(input_string)
{
indent_size := 4
current_indent := 0
result := ""
;MsgBox, % input_string
input_string := input_string
Loop, Parse, input_string, `n, `r
{

trimmed_line := Trim(A_LoopField)

if (trimmed_line = Chr(123))
{

result .= ((A_Space . RepeatSpaces(current_indent)) . (trimmed_line . "`n"))
current_indent := current_indent + indent_size
}
else if (trimmed_line = Chr(125))
{

current_indent := current_indent - indent_size
result .= ((A_Space . RepeatSpaces(current_indent)) . (trimmed_line . "`n"))
}
else
{

result .= ((A_Space . RepeatSpaces(current_indent)) . (trimmed_line . "`n"))
}

}

; Return the result
return result
}

RepeatSpaces(count)
{
spaces := ""
Loop, %count%
{
spaces .= A_Space
}
return spaces
}



ifTheLineIsAFuncDec(strgjvkh, theFuncWeFound)
{
Loop, Parse, theFuncWeFound, `n, `r
{

numOfChars := 0
Loop, Parse, A_LoopField
{
numOfChars++
}

A_LoopFieldd := StrSplit(A_LoopField, Chr(40), 1)
A_LoopFieldd2 := StrSplit(strgjvkh, Chr(40), 1)

if (SubStr(A_LoopFieldd, 1, numOfChars) = A_LoopFieldd2) && (InStr(strgjvkh, Chr(40)))
{
return true
}


}

return false
}


StrSplit123(str, delimiter, num)
{

if (num = 1)
{
out := ""
Loop, Parse, str
{

out .= A_LoopField

if (A_LoopField = delimiter)
{
StringTrimRight, out, out, 1
break
}

}
return out
}
else
{

str := delimiter . str

posNum := 0
allowPos := 0
out := ""
Loop, Parse, str
{

if (allowPos = 1)
{
out .= A_LoopField
}

if (A_LoopField = delimiter) && (allowPos = 1)
{

if (pos = num)
{
StringTrimRight, out, out, 1
break
}
else
{
allowPos := 0
out := ""
}

}
if (A_LoopField = delimiter) && (allowPos = 0)
{
allowPos := 1
posNum++
pos := posNum
}


} ; end of Loop
return out
}


} ; end of func



transpileVariables(str, functionNames)
{
Trim(str)
numOfStrings := 0

str := StrReplace(str, Chr(34) . Chr(34), "cyiasasasasstAYtheummonlyemlpystringya-a-" . Chr(100))



if (InStr(str, Chr(34)))
{
;OutputDebug, |||%str%|||

Loop, Parse, str, " "
{
theString%A_Index% := ""
}
theString1 := ""
theString2 := ""
theString3 := ""
theString4 := ""
theString5 := ""


posStartToGetString := 0
numGetStringTheSatring := 0

outOfstr11 := ""
str := Chr(34) . Chr(34) . str . Chr(34)
Loop, Parse, str
{
;OutputDebug, |?|%A_LoopField%|?|
if (posStartToGetString = 2)
{
posStartToGetString := 0
ONCEposStartToGetString := 0
}

if (posStartToGetString = 1) && (A_LoopField != Chr(34))
{
theString%numGetStringTheSatring% .= A_LoopField
ONCEposStartToGetString++
if (ONCEposStartToGetString = 1)
{
outOfstr11 .= "freeeeepaestine-sav-etehmtyeah-freee-n" . numOfStrings
}
}
else
{
if (A_LoopField != Chr(34))
{
outOfstr11 .= A_LoopField
}
}

if (A_LoopField = Chr(34))
{
posStartToGetString++
if (posStartToGetString = 1)
{
numGetStringTheSatring++
numOfStrings++
}
}


} ; loop


}
else
{
outOfstr11 := str
}

;OutputDebug, |%outOfstr11%|
outOftranspileVariables := ""
outOftranspileVariablesOut := Trim(outOfstr11)



outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(40), " ( ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(41), " ) ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(44), " , ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(60), " < ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(62), " > ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(91), " [ ")
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(93), " ] ")

wasHereVarTryUhBug := 1
Loop, Parse, outOftranspileVariablesOut, " "
{
howManyCharIfVar := 0
Loop, Parse, A_LoopField
{
if (varDetect(A_LoopField))
{
howManyCharIfVar++
}
}
howManyCharIfVar2 := 0
Loop, Parse, A_LoopField
{
howManyCharIfVar2++
}
istAvar := 0
if (howManyCharIfVar = howManyCharIfVar2)
{
istAvar := 1
}

if (istAvar = 1)
{

howManyCharIfVar := 0
Loop, Parse, A_LoopField
{
if (isVarAnumKindaVar(A_LoopField))
{
howManyCharIfVar++
}
}

howManyCharIfVar2 := 0
Loop, Parse, A_LoopField
{
howManyCharIfVar2++
}
isNumKindaVar := 0
if (howManyCharIfVar2 = howManyCharIfVar)
{
isNumKindaVar := 1
}

if (isNumKindaVar = 1)
{
outOftranspileVariables .= A_LoopField . A_Space
}
else
{

if (InStr(A_LoopField, "%"))
{
var1 := StrSplit(A_LoopField, "%", 1)
var2 := StrSplit(A_LoopField, "%", 2)
out1 := "variables[f" . Chr(39) . var1 . "{variables[" . Chr(34) . var2 . Chr(34) . "]}" . Chr(39) . "]"
outOftranspileVariables .= out1 . A_Space
}
else
{
out1 := "variables[" . Chr(39) . A_LoopField . Chr(39) . "]"
outOftranspileVariables .= out1 . A_Space
}
}


}
else
{
outOftranspileVariables .= A_LoopField . A_Space
}
wasHereVarTryUhBug := 0
}

if (wasHereVarTryUhBug = 1)
{
outOftranspileVariables := outOftranspileVariablesOut
}

;OutputDebug, |%outOftranspileVariables%|

outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['True']", "True")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['False']", "False")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['true']", "True")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['false']", "False")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['if']", "if")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['else']", "else")

outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['and']", "and")
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['or']", "or")

outOftranspileVariables := StrReplace(outOftranspileVariables, "!", " not ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " && ", " and ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " || ", " or ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " < = ", " <= ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " > = ", " >= ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " = ", " == ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " = ", " == ")
outOftranspileVariables := StrReplace(outOftranspileVariables, "  not == ", " != ")

outOftranspileVariables := StrReplace(outOftranspileVariables, " ( ", Chr(40))
outOftranspileVariables := StrReplace(outOftranspileVariables, " ) ", Chr(41))
outOftranspileVariables := StrReplace(outOftranspileVariables, " )", Chr(41))
outOftranspileVariables := StrReplace(outOftranspileVariables, " < ", Chr(60))
outOftranspileVariables := StrReplace(outOftranspileVariables, " > ", Chr(62))

outOftranspileVariables := StrReplace(outOftranspileVariables, "  >= ", " >= ")
outOftranspileVariables := StrReplace(outOftranspileVariables, "  <= ", " <= ")

outOftranspileVariables := StrReplace(outOftranspileVariables, " . ", " + ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " ,  ", ", ")
outOftranspileVariables := StrReplace(outOftranspileVariables, " [ ", "[")
outOftranspileVariables := StrReplace(outOftranspileVariables, " ] ", "]")

Loop, Parse, functionNames, "|"
{
outOftranspileVariables := StrReplace(outOftranspileVariables, "variables['" . A_LoopField . "']", A_LoopField)
}


Loop, % numOfStrings
{
outOftranspileVariables := StrReplace(outOftranspileVariables, "freeeeepaestine-sav-etehmtyeah-freee-n" . A_Index, Chr(34) . theString%A_Index% . Chr(34))
}

weEverUseVars := "# Define a dictionary to store dynamic variables`nvariables = {}`n`n"
;OutputDebug, |%outOftranspileVariables%|
outOftranspileVariables := Trim(outOftranspileVariables)

outOftranspileVariables := StrReplace(outOftranspileVariables, Chr(96), Chr(92))
outOftranspileVariables := StrReplace(outOftranspileVariables, Chr(92) . Chr(92), Chr(96))
outOftranspileVariables := StrReplace(outOftranspileVariables, "cyiasasasasstAYtheummonlyemlpystringya-a-" . Chr(100), Chr(34) . Chr(34))



return outOftranspileVariables
}






transpileLowVariables(str)
{
Trim(str)
numOfStrings := 0
if (InStr(str, Chr(37)))
{

Loop, Parse, str, "%"
{
theString%A_Index% := ""
}


posStartToGetString := 0
numGetStringTheSatring := 0

outOfstr11 := ""
Loop, Parse, str
{

if (posStartToGetString = 2)
{
posStartToGetString := 0
ONCEposStartToGetString := 0
}

if (posStartToGetString = 1) && (A_LoopField != Chr(37))
{
theString%numGetStringTheSatring% .= A_LoopField
ONCEposStartToGetString++
if (ONCEposStartToGetString = 1)
{
outOfstr11 .= "freeeeepaestine-sav-etehmtyeah-freee-n" . numOfStrings
}
}
else
{
if (A_LoopField != Chr(37))
{
outOfstr11 .= A_LoopField
}
}

if (A_LoopField = Chr(37))
{
posStartToGetString++
if (posStartToGetString = 1)
{
numGetStringTheSatring++
numOfStrings++
}
}


} ; loop


}
else
{
outOfstr11 := str
}

;OutputDebug, |%outOfstr11%|
outOftranspileVariables := ""
outOftranspileVariablesOut := Chr(34) . Trim(outOfstr11)



Loop, % numOfStrings
{
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, "freeeeepaestine-sav-etehmtyeah-freee-n" . A_Index, Chr(34) . " + variables[" . Chr(39) . theString%A_Index% . Chr(39) . "] + " . Chr(34))
}
outOftranspileVariablesOut .= Chr(34)
nothing := ""
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, Chr(34) . Chr(34) . " + ", nothing)
outOftranspileVariablesOut := StrReplace(outOftranspileVariablesOut, " + " . Chr(34) . Chr(34), nothing)

weEverUseVars := "# Define a dictionary to store dynamic variables`nvariables = {}`n`n"

return outOftranspileVariablesOut
}







isVarAnumKindaVar(str)
{

strLettersStart := 48
Loop, 10
{
if (InStr(str, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}

if (InStr(str, Chr(95)))
{
return true
}


return false
}

varDetect(str)
{

strLettersStart := 97
Loop, 26
{
if (InStr(str, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}


strLettersStart := 65
Loop, 26
{
if (InStr(str, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}


strLettersStart := 48
Loop, 10
{
if (InStr(str, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}

if (InStr(str, Chr(95)))
{
return true
}

if (InStr(str, Chr(37)))
{
return true
}

return false
}


funcToChecIfVaidNameForFunc(str)
{
    ; Check if the string is empty
    if (!(str))
    {
        ;MsgBox, Invalid function name: %str% (empty string)
        return false
    }

    ; Check if the first character is a digit (invalid for function name)
    firstChar := SubStr(str, 1, 1)
    if (firstChar >= "0" && firstChar <= "9")
    {
     ;   MsgBox, Invalid function name: %str% (starts with a digit)
        return false
    }

    ; Initialize a flag for validation
    isValid := true

    ; Loop through each character in the string using Loop, Parse
    Loop, Parse, str
    {
        ; Check the current parsed item (character)
        char := A_LoopField

        ; Check if the character is a valid letter, digit, or underscore
        if !(char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char = "_")
        {
           ; MsgBox, Invalid character %char% in function name: %str%
            isValid := false
            break
        }
    }

    ; If passed all checks, return true (valid function name)
    return isValid
}